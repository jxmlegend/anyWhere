//==============================================================================
//
//  File        : sensor_ov4689.c
//  Description : Firmware Sensor Control File
//  Author      :
//  Revision    : 1.0
//
//==============================================================================

//==============================================================================
//
//                              INCLUDE FILE
//
//==============================================================================

#include "includes_fw.h"
#include "customer_config.h"

#if (SENSOR_EN)
#if (BIND_SENSOR_OV4689)

#include "mmpf_sensor.h"
#include "Sensor_Mod_Remapping.h"
#include "isp_if.h"
#include "hdr_cfg.h"
#include "snr_cfg.h"

//==============================================================================
//
//                              MACRO DEFINE
//
//==============================================================================

#define ADD_VTS         (1)

#define MAX_SENSOR_GAIN (16)
#define ISP_DGAIN_BASE  (0x200)

//==============================================================================
//
//                              GLOBAL VARIABLE
//
//==============================================================================

// Resolution Table
#if (HDR_FOV_ENLARGE)
MMPF_SENSOR_RESOLUTION m_SensorRes = 
{
    16,     // ubSensorModeNum
    0,      // ubDefPreviewMode
    5,      // ubDefCaptureMode
    2000,   // usPixelSize
//   HDR    FHD@60  FHD/1440@30                                                                     HD@120                  4K@24 
// 	Mode0   Mode1   Mode2	Mode3   Mode4   Mode5   Mode6   Mode7   Mode8   Mode9   Mode10  Mode11  Mode12	Mode13  Mode14  Mode15
    {1,		1,		1,    	1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      3,      1},    	// usVifGrabStX
    {1,     1,		1,    	1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      3,      1},    	// usVifGrabStY
    {2436,	2692,	2692, 	1288,   1928,   1928,   1928,   2032,   1928,   1288,   1288,   1288,   1288,	644,    1516,   2692}, 	// usVifGrabW
    {1370,	1524,	1524,  	964,    1092,   1092,   1092,   1524,   1092,   724,    724,    724,    724,    482,    1516,   1524}, 	// usVifGrabH
#if (CHIP == MCR_V2)
    {1,		1,		1,     	1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1},    	// usBayerInGrabX
    {1,		1,		1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1},    	// usBayerInGrabY
    {4,		4,		4,   	8,      8,      8,      8,      8,    	8,      8,      8,      8,      4,      4,      4,      4},   	// usBayerInDummyX
    {2,		12,		12,     4,      12,     12,     12,     4,     	12,     4,      4,      4,      4,      2,      4,      12},    // usBayerInDummyY
    {2432,	1920,	2560, 	1280,   1920,   1920,   1920,   2024,   1920,   1280,   1280,   1280,   1280, 	640,    1512,   2688},	// usBayerOutW
    {1368,	1080,	1440,  	960,    1080,   1080,   1080,   1520,   1080,   720,    720,    720,    720,    480,    1512,   1512}, 	// usBayerOutH
#endif
    #if (SUPPORT_EIS)
    {1920,	1920,	1920, 	1280,   1920,   1920,   1920,   1920,   1920,   1280,   1280,   1280,   1280,	640,    1512,   2688}, 	// usScalInputW
    {1080,	1080,	1080,  	960,   	1080,   1080,   1080,   1080,   1080,  	720,    720,    720,    720,    480,    1512,   1512}, 	// usScalInputH
    #else
    {2432,	1920,	2560, 	1280,   1920,   1920,   1920,   2024,   1920,   1280,   1280,   1280,   1280,	640,    1512,   2688}, 	// usScalInputW
    {1368,	1080,	1440,  	960,   	1080,   1080,   1080,   1520,   1080,  	720,    720,    720,    720,    480,    1512,   1512}, 	// usScalInputH
    #endif
#ifdef SPECIAL_VERSION_15FPS
    #if SPECIAL_VERSION_15FPS
    {150,   150,    150,   	150,    150,    150,    150,    150,    150,    150,    150,    1000,   1200,	300,    300,    120}, 	// usTargetFpsx10
    {1265,	1562,	1562, 	1597,   1136,   1136,   1120,   1558,   1136,   1597,	797,    797,    797,   1589,    1552,   1562},	// usVsyncLine
    #else
    {300,   600,    300,   	300,    300,    500,    600,    300,    150,    300,    600,    1000,   1200,	300,    300,    240}, 	// usTargetFpsx10
    {1392,	1562,	1562, 	1597,   1136,   1136,   1120,   1558,   1136,   1597,	797,    797,    797,   1589,    1552,   1562},	// usVsyncLine
    #endif
#else
    {300,   600,    300,   	300,    300,    500,    600,    300,    150,    300,    600,   	1000,   1200,	300,    300,    240}, 	// usTargetFpsx10
    #if (ADD_VTS)
    {1540,	1600,	1562, 	1597,   1136,   1136,   1120,   1558,   1136,   1597,	797,    797,    821,   1589,    1552,   1562},	// usVsyncLine (VTS: Reg0x380E-F)
    #else
    {1408,	1562,	1562, 	1597,   1136,   1136,   1120,   1558,   1136,   1597,	797,    797,    797,   1589,    1552,   1562},	// usVsyncLine (VTS: Reg0x380E-F)
    #endif  
#endif
    {1,		1,		1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1},    	// ubWBinningN
    {1,		1,		1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1},    	// ubWBinningM
    {1,		1,		1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1},    	// ubHBinningN
    {1,		1,		1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1},     // ubHBinningM
    {0xFF,	0xFF,	0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF},  // ubCustIQmode
    {0xFF,	0xFF,	0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF}   // ubCustAEmode
};
#else
MMPF_SENSOR_RESOLUTION m_SensorRes = 
{
    16,     // ubSensorModeNum
    0,      // ubDefPreviewMode
    5,      // ubDefCaptureMode
    2000,   // usPixelSize
//   HDR    FHD@60  FHD/1440@30                                                                     HD@120                  4K@24     
// 	Mode0   Mode1   Mode2	Mode3	Mode4   Mode5   Mode6   Mode7   Mode8   Mode9   Mode10  Mode11	Mode12	Mode13  Mode14  Mode15
    {1,		1,		1,    	1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1},    	// usVifGrabStX
    {1, 	1,		1,    	1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1},    	// usVifGrabStY
    {2312,	2562,	2692, 	1288,   1928,   1928,   1928,   2032,   1928,   1288,   1288,   1288,   1288,	644,    1516,   2692}, 	// usVifGrabW
    {1520,	1448,	1524,  	964,   	1092,   1092,   1092,   1524,   1092, 	724,    724,    724,    724,    482,    1516,   1524}, 	// usVifGrabH
#if (CHIP == MCR_V2)
    {1,		1,		1,     	1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1},    	// usBayerInGrabX
    {1,		1,		1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1},    	// usBayerInGrabY
    {8,		2,		4,   	8,      8,      8,      8,     	8,    	8,      8,      8,      8,      8,      4,      4,      4},   	// usBayerInDummyX
    {224,	8,		12,     4,     	12,     12,     12,     4,     	12,   	4,      4,      4,      4,      2,      4,      12},    // usBayerInDummyY
    {2304,	2560,	2560, 	1280,   1920,   1920,   1920,   2024,   1920,   1280,   1280,   1280,   1280, 	640,    1512,   2688},	// usBayerOutW
    {1296,	1440,	1440,  	960,   	1080,   1080,   1080,   1520,   1080, 	720,    720,    720,    720,    480,    1512,   1512}, 	// usBayerOutH
#endif
    #if (SUPPORT_EIS)
    {1920,	1920,	1920, 	1280,   1920,   1920,   1920,   1920,   1920,   1280,   1280,   1280,   1280,	640,    1512,   2688}, 	// usScalInputW
    {1080,	1080,	1080,  	960,   	1080,   1080,   1080,   1080,   1080,  	720,    720,    720,    720,    480,    1512,   1512}, 	// usScalInputH
    #else
    {2304,	2560,	2560, 	1280,   1920,   1920,   1920,   2024,   1920,   1280,   1280,   1280,   1280,	640,    1512,   2688}, 	// usScalInputW
    {1296,	1440,	1440,  	960,   	1080,   1080,   1080,   1520,   1080,  	720,    720,    720,    720,    480,    1512,   1512}, 	// usScalInputH
    #endif
    {400,	600,	300,   	300,    300,    500,    600,    300,    150,    300,    600,   	1000,   1200,	300,    300,    240}, 	// usTargetFpsx10
    {1167,	1554,	1562, 	1597,   1136,   1136,   1128,   1558,   1136,   1597,	797,    797,    797,   	1589,   1548,   1562},	// usVsyncLine
    {1,		1,		1,     	1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1},    	// ubWBinningN
    {1,		1,		1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1},    	// ubWBinningM
    {1,		1,		1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1},    	// ubHBinningN
    {1,		1,		1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1},     // ubHBinningM
    {0xFF,	0xFF,	0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF},  // ubCustIQmode
    {0xFF,	0xFF,	0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF}   // ubCustAEmode
};
#endif

// VIF Setting
static MMPF_SENSOR_VIF_SETTING m_VifSetting_Prm =
{
    // SnrType
    MMPF_VIF_SNR_TYPE_BAYER,

    // OutInterface
    #if (SENSOR_IF == SENSOR_IF_PARALLEL)
    MMPF_VIF_IF_PARALLEL,
    #elif (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
    MMPF_VIF_IF_MIPI_SINGLE_0,
    #elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
    MMPF_VIF_IF_MIPI_DUAL_01,
    #elif (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
    MMPF_VIF_IF_MIPI_QUAD,
    #endif

    // VifPadId
    #if (PRM_SENSOR_VIF_ID == MMPF_VIF_MDL_ID1)
    MMPF_VIF_MDL_ID1,
    #else
    MMPF_VIF_MDL_ID0,
    #endif

    // powerOnSetting
    {
        MMP_TRUE,                       // bTurnOnExtPower
        SENSOR_GPIO_ENABLE,             // usExtPowerPin
        SENSOR_GPIO_ENABLE_ACT_LEVEL,   // bExtPowerPinHigh
        50,                             // usExtPowerPinDelay
        MMP_FALSE,                      // bFirstEnPinHigh
        10,                             // ubFirstEnPinDelay
        MMP_TRUE,                       // bNextEnPinHigh
        100,                            // ubNextEnPinDelay
        MMP_TRUE,                       // bTurnOnClockBeforeRst
        MMP_FALSE,                      // bFirstRstPinHigh
        100,                            // ubFirstRstPinDelay
        MMP_TRUE,                       // bNextRstPinHigh
        100                             // ubNextRstPinDelay
    },

    // powerOffSetting
    {
        MMP_FALSE,                      // bEnterStandByMode
        0x0100,                         // usStandByModeReg
        0x01,                           // usStandByModeMask
        MMP_TRUE,                       // bEnPinHigh
        20,                             // ubEnPinDelay
        MMP_TRUE,                       // bTurnOffMClock
        MMP_TRUE,                       // bTurnOffExtPower
        SENSOR_GPIO_ENABLE              // usExtPowerPin
    },

    // clockAttr
    {
        MMP_TRUE,                       // bClkOutEn
        0,                              // ubClkFreqDiv
        24000,                          // ulMClkFreq
        24000,			                // ulDesiredFreq
        MMPF_VIF_SNR_PHASE_DELAY_NONE,  // ubClkPhase
        MMPF_VIF_SNR_CLK_POLARITY_POS,  // ubClkPolarity
        MMPF_VIF_SNR_CLK_SRC_PMCLK      // ubClkSrc
    },

    // paralAttr
    {
        MMPF_VIF_SNR_LATCH_POS_EDGE,    // ubLatchTiming
        MMPF_VIF_SNR_CLK_POLARITY_POS,  // ubHsyncPolarity
        MMPF_VIF_SNR_CLK_POLARITY_POS,  // ubVsyncPolarity
        MMPF_VIF_SNR_PARAL_BITMODE_16   // ubBusBitMode
    },

    // mipiAttr
    {
        MMP_FALSE,                      // bClkDelayEn
        MMP_FALSE,                      // bClkLaneSwapEn
        0,                              // usClkDelay
        MMPF_VIF_SNR_LATCH_NEG_EDGE,    // ubBClkLatchTiming
#if (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
        // Lane 0,                      Lane 1,                             Lane 2,                             Lane 3
        {MMP_TRUE,                      MMP_TRUE,                           MMP_TRUE,                           MMP_TRUE},                          // bDataLaneEn
        {MMP_TRUE,                      MMP_TRUE,                           MMP_TRUE,                           MMP_TRUE},                          // bDataDelayEn
        {MMP_FALSE,                     MMP_FALSE,                          MMP_FALSE,                          MMP_FALSE},                         // bDataLaneSwapEn
        {MMPF_VIF_MIPI_DATA_SRC_PHY_0,  MMPF_VIF_MIPI_DATA_SRC_PHY_1,       MMPF_VIF_MIPI_DATA_SRC_PHY_2,       MMPF_VIF_MIPI_DATA_SRC_PHY_3},      // ubDataLaneSrc
        {0,                             0,                                  0,                                  0},                                 // usDataDelay
        {0x1F,                          0x1F,                               0x1F,                               0x1F}                               // ubDataSotCnt
#elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
        // Lane 0,                      Lane 1,                             Lane 2,                             Lane 3
        {MMP_TRUE,                      MMP_TRUE,                           MMP_FALSE,                          MMP_FALSE},                         // bDataLaneEn
        {MMP_TRUE,                      MMP_TRUE,                           MMP_FALSE,                          MMP_FALSE},                         // bDataDelayEn
        {MMP_FALSE,                     MMP_FALSE,                          MMP_FALSE,                          MMP_FALSE},                         // bDataLaneSwapEn
        #if (PRM_SENSOR_VIF_ID == MMPF_VIF_MDL_ID1)
        {MMPF_VIF_MIPI_DATA_SRC_PHY_1,  MMPF_VIF_MIPI_DATA_SRC_PHY_2,       MMPF_VIF_MIPI_DATA_SRC_PHY_UNDEF,   MMPF_VIF_MIPI_DATA_SRC_PHY_UNDEF},  // ubDataLaneSrc
        #else
        {MMPF_VIF_MIPI_DATA_SRC_PHY_0,  MMPF_VIF_MIPI_DATA_SRC_PHY_1,       MMPF_VIF_MIPI_DATA_SRC_PHY_UNDEF,   MMPF_VIF_MIPI_DATA_SRC_PHY_UNDEF},  // ubDataLaneSrc
        #endif
        {0,                             0,                                  0,                                  0},                                 // usDataDelay
        {0x1F,                          0x1F,                               0x1F,                               0x1F}                               // ubDataSotCnt
#elif (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
        // Lane 0,                      Lane 1,                             Lane 2,                             Lane 3
        {MMP_TRUE,                      MMP_FALSE,                          MMP_FALSE,                          MMP_FALSE},                         // bDataLaneEn
        {MMP_TRUE,                      MMP_FALSE,                          MMP_FALSE,                          MMP_FALSE},                         // bDataDelayEn
        {MMP_FALSE,                     MMP_FALSE,                          MMP_FALSE,                          MMP_FALSE},                         // bDataLaneSwapEn
        {MMPF_VIF_MIPI_DATA_SRC_PHY_0,  MMPF_VIF_MIPI_DATA_SRC_PHY_UNDEF,   MMPF_VIF_MIPI_DATA_SRC_PHY_UNDEF,   MMPF_VIF_MIPI_DATA_SRC_PHY_UNDEF},  // ubDataLaneSrc
        {0,                             0,                                  0,                                  0},                                 // usDataDelay
        {0x1F,                          0x1F,                               0x1F,                               0x1F}                               // ubDataSotCnt
#endif
    },

    // colorId
    {
    #if SENSOR_ROTATE_180 
        MMPF_VIF_COLORID_00,            // VifColorId
    #else
        MMPF_VIF_COLORID_11,            // VifColorId
    #endif    
        MMP_FALSE                       // bUseCustomId
    },

    // vcAttr
    {
        MMP_FALSE,                                      	// bEnable
        MMP_FALSE,                                      	// bAllChannel2Isp
        {MMP_FALSE, MMP_FALSE, MMP_FALSE, MMP_FALSE},   	// bVC2Isp
        {MMP_FALSE, MMP_FALSE, MMP_FALSE, MMP_FALSE},  	    // bVC2Raw
        MMP_FALSE                                       	// bSlowFsForStagger
    },

    // yuvAttr
    {
        MMP_FALSE,                                      	// bRawStoreEnable
        // MMP_FALSE,                                      	// bYuv422ToYuv420
        // MMP_FALSE,                                      	// bYuv422ToYuv422
        // MMP_FALSE,                                      	// bYuv422ToBayer
        // MMPF_VIF_YUV422_YUYV,                           	// ubYuv422Order
    }
};

#if defined(BIND_SENSOR_OV4689_2ND) && (BIND_SENSOR_OV4689_2ND)
static MMPF_SENSOR_VIF_SETTING m_VifSetting_Scd = 
{
    // SnrType
    MMPF_VIF_SNR_TYPE_BAYER,

    // OutInterface
    #if (SENSOR_IF == SENSOR_IF_PARALLEL)
    MMPF_VIF_IF_PARALLEL,
    #elif (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
    MMPF_VIF_IF_MIPI_SINGLE_0,
    #elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
    MMPF_VIF_IF_MIPI_DUAL_01,
    #elif (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
    MMPF_VIF_IF_MIPI_QUAD,
    #endif

    // VifPadId
    MMPF_VIF_MDL_ID1,

    // powerOnSetting
    {
        MMP_TRUE,                       // bTurnOnExtPower
        SENSOR_GPIO_ENABLE,             // usExtPowerPin
        SENSOR_GPIO_ENABLE_ACT_LEVEL,   // bExtPowerPinHigh
        50,                             // usExtPowerPinDelay
        MMP_FALSE,                      // bFirstEnPinHigh
        10,                             // ubFirstEnPinDelay
        MMP_TRUE,                       // bNextEnPinHigh
        100,                            // ubNextEnPinDelay
        MMP_TRUE,                       // bTurnOnClockBeforeRst
        MMP_FALSE,                      // bFirstRstPinHigh
        100,                            // ubFirstRstPinDelay
        MMP_TRUE,                       // bNextRstPinHigh
        100                             // ubNextRstPinDelay
    },

    // powerOffSetting
    {
        MMP_FALSE,                      // bEnterStandByMode
        0x0100,                         // usStandByModeReg
        0x01,                           // usStandByModeMask
        MMP_TRUE,                       // bEnPinHigh
        20,                             // ubEnPinDelay
        MMP_TRUE,                       // bTurnOffMClock
        MMP_TRUE,                       // bTurnOffExtPower
        SENSOR_GPIO_ENABLE              // usExtPowerPin
    },

    // clockAttr
    {
        MMP_TRUE,                       // bClkOutEn
        0,                              // ubClkFreqDiv
        24000,                          // ulMClkFreq
        24000,			                // ulDesiredFreq
        MMPF_VIF_SNR_PHASE_DELAY_NONE,  // ubClkPhase
        MMPF_VIF_SNR_CLK_POLARITY_POS,  // ubClkPolarity
        MMPF_VIF_SNR_CLK_SRC_PMCLK      // ubClkSrc
    },

    // paralAttr
    {
        MMPF_VIF_SNR_LATCH_POS_EDGE,    // ubLatchTiming
        MMPF_VIF_SNR_CLK_POLARITY_POS,  // ubHsyncPolarity
        MMPF_VIF_SNR_CLK_POLARITY_POS,  // ubVsyncPolarity
        MMPF_VIF_SNR_PARAL_BITMODE_16   // ubBusBitMode
    },

    // mipiAttr
    {
        MMP_FALSE,                      // bClkDelayEn
        MMP_FALSE,                      // bClkLaneSwapEn
        0,                              // usClkDelay
        MMPF_VIF_SNR_LATCH_NEG_EDGE,    // ubBClkLatchTiming
#if (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
        // Lane 0,                      Lane 1,                             Lane 2,                             Lane 3
        {MMP_TRUE,                      MMP_TRUE,                           MMP_TRUE,                           MMP_TRUE},                          // bDataLaneEn
        {MMP_TRUE,                      MMP_TRUE,                           MMP_TRUE,                           MMP_TRUE},                          // bDataDelayEn
        {MMP_FALSE,                     MMP_FALSE,                          MMP_FALSE,                          MMP_FALSE},                         // bDataLaneSwapEn
        {MMPF_VIF_MIPI_DATA_SRC_PHY_0,  MMPF_VIF_MIPI_DATA_SRC_PHY_1,       MMPF_VIF_MIPI_DATA_SRC_PHY_2,       MMPF_VIF_MIPI_DATA_SRC_PHY_3},      // ubDataLaneSrc
        {0,                             0,                                  0,                                  0},                                 // usDataDelay
        {0x1F,                          0x1F,                               0x1F,                               0x1F}                               // ubDataSotCnt
#elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
        // Lane 0,                      Lane 1,                             Lane 2,                             Lane 3
        {MMP_TRUE,                      MMP_TRUE,                           MMP_FALSE,                          MMP_FALSE},                         // bDataLaneEn
        {MMP_TRUE,                      MMP_TRUE,                           MMP_FALSE,                          MMP_FALSE},                         // bDataDelayEn
        {MMP_FALSE,                     MMP_FALSE,                          MMP_FALSE,                          MMP_FALSE},                         // bDataLaneSwapEn
        {MMPF_VIF_MIPI_DATA_SRC_PHY_1,  MMPF_VIF_MIPI_DATA_SRC_PHY_2,       MMPF_VIF_MIPI_DATA_SRC_PHY_UNDEF,   MMPF_VIF_MIPI_DATA_SRC_PHY_UNDEF},  // ubDataLaneSrc
        {0,                             0,                                  0,                                  0},                                 // usDataDelay
        {0x1F,                          0x1F,                               0x1F,                               0x1F}                               // ubDataSotCnt
#elif (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
        // Lane 0,                      Lane 1,                             Lane 2,                             Lane 3
        {MMP_TRUE,                      MMP_FALSE,                          MMP_FALSE,                          MMP_FALSE},                         // bDataLaneEn
        {MMP_TRUE,                      MMP_FALSE,                          MMP_FALSE,                          MMP_FALSE},                         // bDataDelayEn
        {MMP_FALSE,                     MMP_FALSE,                          MMP_FALSE,                          MMP_FALSE},                         // bDataLaneSwapEn
        {MMPF_VIF_MIPI_DATA_SRC_PHY_0,  MMPF_VIF_MIPI_DATA_SRC_PHY_UNDEF,   MMPF_VIF_MIPI_DATA_SRC_PHY_UNDEF,   MMPF_VIF_MIPI_DATA_SRC_PHY_UNDEF},  // ubDataLaneSrc
        {0,                             0,                                  0,                                  0},                                 // usDataDelay
        {0x1F,                          0x1F,                               0x1F,                               0x1F}                               // ubDataSotCnt
#endif
    },

    // colorId
    {
    #if SENSOR_ROTATE_180 
        MMPF_VIF_COLORID_00,            // VifColorId
    #else
        MMPF_VIF_COLORID_11,            // VifColorId
    #endif    
        MMP_FALSE                       // bUseCustomId
    },

    // vcAttr
    {
        MMP_FALSE,                                      	// bEnable
        MMP_FALSE,                                      	// bAllChannel2Isp
        {MMP_FALSE, MMP_FALSE, MMP_FALSE, MMP_FALSE},   	// bVC2Isp
        {MMP_FALSE, MMP_FALSE, MMP_FALSE, MMP_FALSE},  	    // bVC2Raw
        MMP_FALSE                                       	// bSlowFsForStagger
    },

    // yuvAttr
    {
        MMP_FALSE,                                      	// bRawStoreEnable
        // MMP_FALSE,                                      	// bYuv422ToYuv420
        // MMP_FALSE,                                      	// bYuv422ToYuv422
        // MMP_FALSE,                                      	// bYuv422ToBayer
        // MMPF_VIF_YUV422_YUYV,                           	// ubYuv422Order
    }
};
#endif

// IQ Table
const ISP_UINT8 Sensor_IQ_CompressedText[] = 
{
#if defined(SUPPORT_UVC_ISP_EZMODE_FUNC) && (SUPPORT_UVC_ISP_EZMODE_FUNC)       
    #include "isp_8428_iq_data_v3_OV4689_ezmode.xls.ciq.txt"
#else // Use old IQ table
    #ifdef CUS_ISP_8428_IQ_DATA     // maybe defined in project MCP or Config_SDK.h
    #include CUS_ISP_8428_IQ_DATA
    #else
    #include "isp_8428_iq_data_v2_OV4689_v1_casio.xls.ciq.txt"
    #endif
#endif
};

#if defined(SUPPORT_UVC_ISP_EZMODE_FUNC) && (SUPPORT_UVC_ISP_EZMODE_FUNC) 
// Replace it by custom IQ table.
const  __align(4) ISP_UINT8 Sensor_EZ_IQ_CompressedText[] = 
{
    #include "isp_8428_iq_data_v3_OV4689_ezmode.iq.custom.txt"
};

ISP_UINT32 eziqsize = sizeof(Sensor_EZ_IQ_CompressedText);
#endif

// I2cm Attribute for primary sensor
static MMP_I2CM_ATTR m_I2cmAttr_Prm = 
{
    MMP_I2CM0,      // i2cmID
/*
 * In the OV4689, the SCCB ID is controlled by the SID pin.
 * If SID pin is low, the sensor's SCCB address comes from register 0x3004 which has a default value of 0x6C.
 * If SID pin is high, the sensor's SCCB address comes from register 0x3012 which has a default value of 0x20.
 * The device slave address are 0x6C for write and 0x6D for read (when SID = 1, 0x20 for write and 0x21 for read).
 */
#if defined (SNR_OV4689_SID_PIN) && (SNR_OV4689_SID_PIN == 1) // defined in Config_xxx.h
    (0x20 >> 1),    // ubSlaveAddr
#else
    (0x6C >> 1),    // ubSlaveAddr
#endif
    16,             // ubRegLen
    8,              // ubDataLen
    0,              // ubDelayTime
    MMP_FALSE,      // bDelayWaitEn
    MMP_TRUE,       // bInputFilterEn
    MMP_FALSE,      // b10BitModeEn
    MMP_FALSE,      // bClkStretchEn
    0,              // ubSlaveAddr1
    0,              // ubDelayCycle
    0,              // ubPadNum
    150000,         // ulI2cmSpeed 150KHZ
    MMP_TRUE,       // bOsProtectEn
    NULL,           // sw_clk_pin
    NULL,           // sw_data_pin
    MMP_FALSE,      // bRfclModeEn
    MMP_FALSE,      // bWfclModeEn
    MMP_FALSE,      // bRepeatModeEn
    0               // ubVifPioMdlId
};

// I2cm Attribute for secondary sensor
#if (BIND_SENSOR_OV4689_2ND)
static MMP_I2CM_ATTR m_I2cmAttr_Scd = 
{
    MMP_I2CM3,      // i2cmID
    /*
     * In the OV4689, the SCCB ID is controlled by the SID pin.
     * If SID pin is low, the sensor's SCCB address comes from register 0x3004 which has a default value of 0x6C.
     * If SID pin is high, the sensor's SCCB address comes from register 0x3012 which has a default value of 0x20.
     * The device slave address are 0x6C for write and 0x6D for read (when SID = 1, 0x20 for write and 0x21 for read).
     */
    #if defined (SNR_OV4689_SID_PIN) && (SNR_OV4689_SID_PIN == 1) // defined in Config_xxx.h
    (0x20 >> 1),    // ubSlaveAddr
    #else
    (0x6C >> 1),    // ubSlaveAddr
    #endif
    16,             // ubRegLen
    8,              // ubDataLen
    0,              // ubDelayTime
    MMP_FALSE,      // bDelayWaitEn
    MMP_TRUE,       // bInputFilterEn
    MMP_FALSE,      // b10BitModeEn
    MMP_FALSE,      // bClkStretchEn
    0,              // ubSlaveAddr1
    0,              // ubDelayCycle
    2,              // ubPadNum
    150000,         // ulI2cmSpeed 150KHZ
    MMP_TRUE,       // bOsProtectEn
    NULL,           // sw_clk_pin
    NULL,           // sw_data_pin
    MMP_FALSE,      // bRfclModeEn
    MMP_FALSE,      // bWfclModeEn
    MMP_FALSE,      // bRepeatModeEn
    0               // ubVifPioMdlId
};
#endif

// 3A Timing
MMPF_SENSOR_AWBTIMIMG m_AwbTime = 
{
    3,  // ubPeriod
    1,  // ubDoAWBFrmCnt
    2   // ubDoCaliFrmCnt
};

MMPF_SENSOR_AETIMIMG m_AeTime = 
{
    4,  // ubPeriod
    0,  // ubFrmStSetShutFrmCnt
    0   // ubFrmStSetGainFrmCnt
};

MMPF_SENSOR_AFTIMIMG m_AfTime = 
{
    1,  // ubPeriod
    0   // ubDoAFFrmCnt
};

// IQ Data
#define ISP_IQ_DATA_NAME "isp_8428_iq_data_v2_OV4689_v1_casio.xls.ciq.txt"

static const MMP_UBYTE s_IqCompressData[] =
{
	#include ISP_IQ_DATA_NAME
};

#if (ISP_EN) //For HDR
static ISP_UINT16 ae_gain_l;
static ISP_UINT16 ae_shutter_l;
static ISP_UINT16 ae_gain_s;
static ISP_UINT16 ae_shutter_s;

ISP_UINT16 hdr_th           = 6;        //fix
ISP_UINT16 hdr_gap          = 7;        //fix
ISP_UINT16 hdr_gain         = 6*256;    //dynamic by code
ISP_UINT16 hdr_short_gain   = 13;       //fix
ISP_UINT16 hdr_x_thd        = 1023;     //fix
ISP_UINT16 hdr_on           = 1;        //hdr on
ISP_UINT16 sensor_max_gain  = 16;       //fix
#endif

ISP_UINT32 dgain;
extern MMP_ULONG  m_ulISPFrameCount;

// Casio : when use this, open code in DoAEOperation_ST
#ifdef CUS_AE_BIAS_TBL		// maybe defined in project's MCP or Config_SDK.h

#include CUS_AE_BIAS_TBL

#else

// AE curve	new extent node for18//LV1,		LV2,		LV3,		LV4,		LV5,		LV6,		LV7,		LV8,		LV9,		LV10,	LV11,	LV12,	LV13,	LV14,	LV15,	LV16 	LV17  	LV18
// test,IQ 8
ISP_UINT32 AE_Bias_tbl[54] =
{
                /*Lux*/	        4,			8,			15,			30,			56, 		118, 		224, 		426, 		810,		1630,	3369,	7101,	14720,	28380,	53300,	110000,	220000, 440000,
                /*ENG*/		    0x2FFFFFF,  4841472*2,	2420736,    1562060,	801396,     439704, 	241131, 	132233, 	72400,		39000,	19000,	11000,	5000,	3084,	1716,	966,	370,    200,
                /*Tar*/	        110,		145,	    175,	    200,		225,		240,		253,		256,		256,		256,	256,	256,	256,	226,	226,	256,	256,    256,
};

#define AE_tbl_size  (18)

#endif

//==============================================================================
//
//                              FUNCTIONS
//
//==============================================================================

#if 0
void ____Sensor_Init_OPR_Table____(){ruturn;} //dummy
#endif

ISP_UINT16 SNR_OV4689_Reg_Init_Customer[] = 
{
    SENSOR_DELAY_REG, 100 // delay
};

#if 0
void ____Sensor_Res_OPR_Table____(){ruturn;} //dummy
#endif

#if (HDR_FOV_ENLARGE)
static ISP_UINT16 SNR_OV4689_Reg_2432x1368_60P_HDR[] = 
{
	//----------------------------------------------
	// MCLK: 24Mhz
	// Mipi : 4 lane 
	// Mipi data rate:480Mbps/Lane
	// Sensor Output:2436x1372 (8bit)
	// SystemCLK   :120MHz
	// #if (ADD_VTS)
	// FPS	    :30.016 fps (long 30.016 fps, short 30.016 fps)
	// HTS		:1298 (R380c:R380d)
	// VTS		:1540 (R380e:R380f)
	// Tline 	: 21.63
	// 
	//
	// #else
	// FPS	    :29.97fps (long 29.97fps, short 29.97fps)
	// HTS		:1422 (R380c:R380d)
	// VTS		:1408 (R380e:R380f)
	// Tline 	: 23.7
	// (T0+T1) < VTS-4 ; T0 is for long exposure frame ; T1 is for middel exposure frame
	// T0 > T1
	// #endif
	//---------------------------------------------

	0x0103, 0x01, 
	SENSOR_DELAY_REG, 100, // delay
	
	0x3638, 0x00, 
	0x0300, 0x00,///0x03xx,///0x04x,///0x00,///0x03,///0x00, 
	0x0302, 0x28,///0x21,///0x53xx,///0x64x,///0x21,///0x4E,///0x1f, 
	0x0303, 0x01,
	0x0304, 0x03, 
	0x030b, 0x00, 
	0x030d, 0x1e, 
	0x030e, 0x04, 
	0x030f, 0x01, 
	0x0312, 0x01, 
	0x031e, 0x00, 
	0x3000, 0x20, 
	0x3002, 0x00, 
	0x3018, 0x72, 
	0x3020, 0x93, 
	0x3021, 0x03, 
	0x3022, 0x01, 
	0x3031, 0x08,//0x0a: 10bit, 0x08: 8bit 
	0x303f, 0x0c,
	0x3305, 0xf1, 
	0x3307, 0x04, 
	0x3309, 0x29, 
	0x3500, 0x00, // long exp.
	0x3501, 0x30, // long exp.
	0x3502, 0x00, // long exp.
	0x3503, 0x64,//0x04,
	0x3504, 0x00, 
	0x3505, 0x00, 
	0x3506, 0x00, 
	0x3507, 0x00, 
	0x3508, 0x07, 
	0x3509, 0xf0, // long: 15.5X
	0x350a, 0x00, // middle exp.
	0x350b, 0x08, // middle exp. 
	0x350c, 0x00, // middle exp
	0x350d, 0x00, 
	0x350e, 0x07, 
	0x350f, 0xf0, // middle : 15.5X
	0x3510, 0x00, 
	0x3511, 0x01, // 00 
	0x3512, 0x00, 
	0x3513, 0x00, 
	0x3514, 0x00, 
	0x3515, 0x80, 
	0x3516, 0x00, 
	0x3517, 0x00, 
	0x3518, 0x00, 
	0x3519, 0x00, 
	0x351a, 0x00, 
	0x351b, 0x80, 
	0x351c, 0x00, 
	0x351d, 0x00, 
	0x351e, 0x00, 
	0x351f, 0x00, 
	0x3520, 0x00, 
	0x3521, 0x80, 
	0x3522, 0x08, 
	0x3524, 0x08, 
	0x3526, 0x08, 
	0x3528, 0x08, 
	0x352a, 0x08, 
	0x3602, 0x00, 
	0x3603, 0x40, 
	0x3604, 0x02, 
	0x3605, 0x00, 
	0x3606, 0x00, 
	0x3607, 0x00, 
	0x3609, 0x12, 
	0x360a, 0x40, 
	0x360c, 0x08, 
	//0x360f, 0xe5, 
	0x360f, 0xe0, 
	0x3608, 0x8f, 
	0x3611, 0x00, 
	0x3613, 0xf7, 
	0x3616, 0x58, 
	0x3619, 0x99, 
	0x361b, 0x60, 
	0x361c, 0x7a, 
	0x361e, 0x79, 
	0x361f, 0x02, 
	0x3632, 0x00, 
	0x3633, 0x10, 
	0x3634, 0x10, 
	0x3635, 0x10, 
	//0x3636, 0x15, 
    0x3636, 0x10,
	0x3646, 0x86, 
	0x364a, 0x0b, 
	0x3700, 0x17, 
	0x3701, 0x22, 
	0x3703, 0x10, 
	0x370a, 0x37, 
	0x3705, 0x00, 
	0x3706, 0x63, 
	0x3709, 0x3c, 
	0x370b, 0x01, 
	0x370c, 0x30, 
	0x3710, 0x24, 
	0x3711, 0x0c, 
	0x3716, 0x00, 
	0x3720, 0x28, 
	0x3729, 0x7b, 
	0x372a, 0x84, 
	0x372b, 0xbd, 
	0x372c, 0xbc, 
	0x372e, 0x52, 
	0x373c, 0x0e, 
	0x373e, 0x33, 
	0x3743, 0x10, 
	0x3744, 0x88, 
	0x3745, 0xc0, 
	0x374a, 0x43, 
	0x374c, 0x00, 
	0x374e, 0x23, 
	0x3751, 0x7b, 
	0x3752, 0x84, 
	0x3753, 0xbd, 
	0x3754, 0xbc, 
	0x3756, 0x52, 
	0x375c, 0x00, 
	0x3760, 0x00, 
	0x3761, 0x00, 
	0x3762, 0x00, 
	0x3763, 0x00, 
	0x3764, 0x00, 
	0x3767, 0x04, 
	0x3768, 0x04, 
	0x3769, 0x08, 
	0x376a, 0x08, 
	0x376b, 0x20, 
	0x376c, 0x00, 
	0x376d, 0x00, 
	0x376e, 0x01, // 00 
	0x3773, 0x00, 
	0x3774, 0x51, 
	0x3776, 0xbd, 
	0x3777, 0xbd, 
	0x3781, 0x18, 
	0x3783, 0x25, 
	0x3798, 0x1b, 
	0x3800, 0x00, 
	0x3801, 0x86,///0x88,///0x84, // 08 
	0x3802, 0x00, 
	0x3803, 0x4e,///0x4c, // 04 
	0x3804, 0x0a, 
	0x3805, 0x19,///0x1b, // 97 
	0x3806, 0x05, 
	0x3807, 0xB1,///0xb3, // fb 
	0x3808, 0x09, 
	0x3809, 0x84,///0x88, // 80 
	0x380a, 0x05, 
	0x380b, 0x5C,///0x60, // f0 
#if ADD_VTS
	0x380c, 0x05, //1298
	0x380d, 0x12,
	0x380e, 0x06, //1540
	0x380f, 0x04,
#else	
	0x380c, 0x05, //1422
	0x380d, 0x8E,
	0x380e, 0x05, 
	0x380f, 0x80, //1408
#endif

	0x3810, 0x00, 
	0x3811, 0x08,///0x0A,///0x08, 
	0x3812, 0x00, 
	0x3813, 0x04, 
	0x3814, 0x01, 
	0x3815, 0x01, 
	0x3819, 0x01, 
#if SENSOR_ROTATE_180
    0x3820, 0x06, // Tom: 0x00: No Flip, 0x06: Row & Column Flip
    0x3821, 0x00, // Tom: 0x06: No Flip, 0x00: Row & Column Flip
#else
	0x3820, 0x00, 
	0x3821, 0x06, 
#endif
	0x3829, 0x00, 
	0x382a, 0x01, 
	0x382b, 0x01, 
	0x382d, 0x7f, 
	0x3830, 0x04, 
	0x3836, 0x01, 
	0x3837, 0x00, 
	0x3841, 0x03, // 02 
	0x3846, 0x08, 
	0x3847, 0x06, // 07 
	0x3d85, 0x36, 
	0x3d8c, 0x71, 
	0x3d8d, 0xcb, 
	0x3f0a, 0x00, 
	0x4000, 0xF1,//0x71, 
	0x4001, 0x40, 
	0x4002, 0x04, 
	0x4003, 0x14, 
	0x400e, 0x00, 
	0x4011, 0x00, 
	0x401a, 0x00, 
	0x401b, 0x00, 
	0x401c, 0x00, 
	0x401d, 0x00, 
	0x401f, 0x00, 
	0x4020, 0x00, 
	0x4021, 0x10, 
	0x4022, 0x08, // 07 
	0x4023, 0x17,///0x13,///0x1B, // cf 
	0x4024, 0x09, 
	0x4025, 0x44,///0x40,///0x48, // 60 
	0x4026, 0x09, 
	0x4027, 0x54,///0x50,///0x58, // 6f 
	0x4028, 0x00, 
	0x4029, 0x02, 
	0x402a, 0x06, 
	0x402b, 0x04, 
	0x402c, 0x02, 
	0x402d, 0x02, 
	0x402e, 0x0e, 
	0x402f, 0x04, 
	0x4302, 0xff, 
	0x4303, 0xff, 
	0x4304, 0x00, 
	0x4305, 0x00, 
	0x4306, 0x00, 
	0x4308, 0x02, 
	0x4500, 0x6c, 
	0x4501, 0xc4, 
	0x4502, 0x40, 
	0x4503, 0x01, 
	0x4601, 0x04, //0x95, //Fix Issue: HDR mode right-up has noise line.
	0x4800, 0x0c, 
	0x4813, 0x08, 
	0x481f, 0x40, 
	0x4829, 0x78, 
	0x4837, 0x21,
	0x4b00, 0x2a, 
	0x4b0d, 0x00, 
	0x4d00, 0x04, 
	0x4d01, 0x42, 
	0x4d02, 0xd1, 
	0x4d03, 0x93, 
	0x4d04, 0xf5, 
	0x4d05, 0xc1, 
	0x5000, 0xf3, 
	0x5001, 0x11, 
	0x5004, 0x00, 
	0x500a, 0x00, 
	0x500b, 0x00, 
	0x5032, 0x00, 
	0x5040, 0x00, 
	0x5050, 0x0c, 
	0x5500, 0x00, 
	0x5501, 0x10, 
	0x5502, 0x01, 
	0x5503, 0x0f, 
	0x8000, 0x00, 
	0x8001, 0x00, 
	0x8002, 0x00, 
	0x8003, 0x00, 
	0x8004, 0x00, 
	0x8005, 0x00, 
	0x8006, 0x00, 
	0x8007, 0x00, 
	0x8008, 0x00, 
	0x3638, 0x00, 
	0x0100, 0x01,  
};
#else
static ISP_UINT16 SNR_OV4689_Reg_2312x1520_60P_HDR[] = 
{
    //----------------------------------------------
    // MCLK: 24Mhz
    // Mipi : 4 lane 
    // Mipi data rate:784Mbps/Lane
    // SystemCLK   :120MHz
    // FPS         :29.98fps (long 29.98fps, short 29.98fps)
    // HTS      :1286 (R380c:R380d)
    // VTS      :1556(R380e:R380f)
    // Tline    : 21.43
    // (T0+T1) < VTS-4 ; T0 is for long exposure frame ; T1 is for middel exposure frame
    // T0 > T1
    //---------------------------------------------

    0x0103, 0x01, 
    0x3638, 0x00, 
    0x0300, 0x01, 
    0x0302, 0x31, 
    0x0303, 0x00,
    0x0304, 0x03, 
    0x030b, 0x00, 
    0x030d, 0x1e, 
    0x030e, 0x04, 
    0x030f, 0x01, 
    0x0312, 0x01, 
    0x031e, 0x00, 
    0x3000, 0x20, 
    0x3002, 0x00, 
    0x3018, 0x72, 
    0x3020, 0x93, 
    0x3021, 0x03, 
    0x3022, 0x01, 
    0x3031, 0x0a, 
    0x303f, 0x0c,
    0x3305, 0xf1, 
    0x3307, 0x04, 
    0x3309, 0x29, 
    0x3500, 0x00, // long exp.
    0x3501, 0x30, // long exp.
    0x3502, 0x00, // long exp.
    0x3503, 0x04, 
    0x3504, 0x00, 
    0x3505, 0x00, 
    0x3506, 0x00, 
    0x3507, 0x00, 
    0x3508, 0x07, 
    0x3509, 0xf0, // long: 15.5X
    0x350a, 0x00, // middle exp.
    0x350b, 0x06, // middle exp. 
    0x350c, 0x00, // middle exp
    0x350d, 0x00, 
    0x350e, 0x07, 
    0x350f, 0xf0, // middle : 15.5X
    0x3510, 0x00, 
    0x3511, 0x01, // 00 
    0x3512, 0x00, 
    0x3513, 0x00, 
    0x3514, 0x00, 
    0x3515, 0x80, 
    0x3516, 0x00, 
    0x3517, 0x00, 
    0x3518, 0x00, 
    0x3519, 0x00, 
    0x351a, 0x00, 
    0x351b, 0x80, 
    0x351c, 0x00, 
    0x351d, 0x00, 
    0x351e, 0x00, 
    0x351f, 0x00, 
    0x3520, 0x00, 
    0x3521, 0x80, 
    0x3522, 0x08, 
    0x3524, 0x08, 
    0x3526, 0x08, 
    0x3528, 0x08, 
    0x352a, 0x08, 
    0x3602, 0x00, 
    0x3603, 0x40, 
    0x3604, 0x02, 
    0x3605, 0x00, 
    0x3606, 0x00, 
    0x3607, 0x00, 
    0x3609, 0x12, 
    0x360a, 0x40, 
    0x360c, 0x08, 
	//0x360f, 0xe5, //1x pregain
    //0x360f, 0xdb,   //1.3x +-
    0x360f, 0xe0,
    0x3608, 0x8f, 
    0x3611, 0x00, 
    0x3613, 0xf7, 
    0x3616, 0x58, 
    0x3619, 0x99, 
    0x361b, 0x60, 
    0x361c, 0x7a, 
    0x361e, 0x79, 
    0x361f, 0x02, 
    0x3632, 0x00, 
    0x3633, 0x10, 
    0x3634, 0x10, 
    0x3635, 0x10, 
	//0x3636, 0x15,
    0x3636, 0x10,
    0x3646, 0x86, 
    0x364a, 0x0b, 
    0x3700, 0x17, 
    0x3701, 0x22, 
    0x3703, 0x10, 
    0x370a, 0x37, 
    0x3705, 0x00, 
    0x3706, 0x63, 
    0x3709, 0x3c, 
    0x370b, 0x01, 
    0x370c, 0x30, 
    0x3710, 0x24, 
    0x3711, 0x0c, 
    0x3716, 0x00, 
    0x3720, 0x28, 
    0x3729, 0x7b, 
    0x372a, 0x84, 
    0x372b, 0xbd, 
    0x372c, 0xbc, 
    0x372e, 0x52, 
    0x373c, 0x0e, 
    0x373e, 0x33, 
    0x3743, 0x10, 
    0x3744, 0x88, 
    0x3745, 0xc0, 
    0x374a, 0x43, 
    0x374c, 0x00, 
    0x374e, 0x23, 
    0x3751, 0x7b, 
    0x3752, 0x84, 
    0x3753, 0xbd, 
    0x3754, 0xbc, 
    0x3756, 0x52, 
    0x375c, 0x00, 
    0x3760, 0x00, 
    0x3761, 0x00, 
    0x3762, 0x00, 
    0x3763, 0x00, 
    0x3764, 0x00, 
    0x3767, 0x04, 
    0x3768, 0x04, 
    0x3769, 0x08, 
    0x376a, 0x08, 
    0x376b, 0x20, 
    0x376c, 0x00, 
    0x376d, 0x00, 
    0x376e, 0x01, // 00 
    0x3773, 0x00, 
    0x3774, 0x51, 
    0x3776, 0xbd, 
    0x3777, 0xbd, 
    0x3781, 0x18, 
    0x3783, 0x25, 
    0x3798, 0x1b, 
    0x3800, 0x00, 	//Xstart
    0x3801, 0xc4,
    0x3802, 0x00,    //Ystart
    0x3803, 0x04,
    0x3804, 0x09,  	//XEnd
    0x3805, 0xdb,
    0x3806, 0x05, 	//YEnd
    0x3807, 0xfb, 
    0x3808, 0x09,  	//XSize
    0x3809, 0x08,
    0x380a, 0x05,  	//YSize
    0x380b, 0xf0,
    0x380c, 0x05, // 05
    0x380d, 0x06, // 10
    0x380e, 0x06, // 05 
    0x380f, 0x14, // 9c ; 12 
    0x3810, 0x00, 
    0x3811, 0x08, 
    0x3812, 0x00, 
    0x3813, 0x04, 
    0x3814, 0x01, 
    0x3815, 0x01, 
    0x3819, 0x01, 
#if SENSOR_ROTATE_180
    0x3820, 0x06, // Tom: 0x00: No Flip, 0x06: Row & Column Flip
    0x3821, 0x00, // Tom: 0x06: No Flip, 0x00: Row & Column Flip
#else
    0x3820, 0x00, 
    0x3821, 0x06, 
#endif
    0x3829, 0x00, 
    0x382a, 0x01, 
    0x382b, 0x01, 
    0x382d, 0x7f, 
    0x3830, 0x04, 
    0x3836, 0x01, 
    0x3837, 0x00, 
    0x3841, 0x03, // 02 
    0x3846, 0x08, 
    0x3847, 0x06, // 07 
    0x3d85, 0x36, 
    0x3d8c, 0x71, 
    0x3d8d, 0xcb, 
    0x3f0a, 0x00, 
    0x4000, 0x71, 
    0x4001, 0x40, 
    0x4002, 0x04, 
    0x4003, 0x14, 
    0x400e, 0x00, 
    0x4011, 0x00, 
    0x401a, 0x00, 
    0x401b, 0x00, 
    0x401c, 0x00, 
    0x401d, 0x00, 
    0x401f, 0x00, 
    0x4020, 0x00, 
    0x4021, 0x10, 
    0x4022, 0x07, // 07 
    0x4023, 0x9b, // f3 ; cf 
    0x4024, 0x08, // 09 
    0x4025, 0xc8, // 20 ; 60 
    0x4026, 0x08, // 09 
    0x4027, 0xd8, // 30 ; 6f 
    0x4028, 0x00, 
    0x4029, 0x02, 
    0x402a, 0x06, 
    0x402b, 0x04, 
    0x402c, 0x02, 
    0x402d, 0x02, 
    0x402e, 0x0e, 
    0x402f, 0x04, 
    0x4302, 0xff, 
    0x4303, 0xff, 
    0x4304, 0x00, 
    0x4305, 0x00, 
    0x4306, 0x00, 
    0x4308, 0x02, 
    0x4500, 0x6c, 
    0x4501, 0xc4, 
    0x4502, 0x40, 
    0x4503, 0x01, 
    0x4601, 0x8f, // 95 ;
    0x4800, 0x0c, 
    0x4813, 0x08, 
    0x481f, 0x40, 
    0x4829, 0x78, 
    0x4837, 0x14,
    0x4b00, 0x2a, 
    0x4b0d, 0x00, 
    0x4d00, 0x04, 
    0x4d01, 0x42, 
    0x4d02, 0xd1, 
    0x4d03, 0x93, 
    0x4d04, 0xf5, 
    0x4d05, 0xc1, 
    0x5000, 0xf3, 
    0x5001, 0x11, 
    0x5004, 0x00, 
    0x500a, 0x00, 
    0x500b, 0x00, 
    0x5032, 0x00, 
    0x5040, 0x00, 
    0x5050, 0x0c, 
    0x5500, 0x00, 
    0x5501, 0x10, 
    0x5502, 0x01, 
    0x5503, 0x0f, 
    0x8000, 0x00, 
    0x8001, 0x00, 
    0x8002, 0x00, 
    0x8003, 0x00, 
    0x8004, 0x00, 
    0x8005, 0x00, 
    0x8006, 0x00, 
    0x8007, 0x00, 
    0x8008, 0x00, 
    0x3638, 0x00, 
    0x0100, 0x01,
};
#endif

//*** FHD@60fps (Index 1)
static ISP_UINT16 SNR_OV4689_Reg_2688x1520_60P[] = 
{
#if (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
/*
 * ----------------------------------------------
 *  MCLK: 24Mhz
 *  resolution: 2692x1524 (8bit)
 *  Mipi: 4 lane
 *  Mipi data rate: 648Mbps/Lane
 *  SystemCLK: 120Mhz
 *  FPS: 60 (= SystemCLK / (HTS * VTS))
 *   #if (ADD_VTS)
 *  HTS: 1250 (R380c:R380d)
 *  VTS: 1600 (R380e:R380f) 
 *  Tline: 10.42us (1250/120)
 *  Max exp line: 1596 (VTS-4)
 *   #else
 *  HTS: 1280 (R380c:R380d)
 *  VTS: 1562 (R380e:R380f)
 *  Tline: 10.67us
 *  Max exp line: 1558 (VTS-4)
 *   #endif
 * ---------------------------------------------
 */
 
    0x0103, 0x01,
    0x3638, 0x00,
    0x0300, 0x00,
    0x0302, 0x1b,///0x1e, // 2a
    0x0303, 0x00, // 00
    0x0304, 0x03,
    0x030b, 0x00,
    0x030d, 0x1e,
    0x030e, 0x04,
    0x030f, 0x01,
#ifdef SPECIAL_VERSION_15FPS
    #if SPECIAL_VERSION_15FPS
    0x0311, 0x01,
    #endif
#endif
    0x0312, 0x01,
    0x031e, 0x00,
    0x3000, 0x20,
    0x3002, 0x00,
    0x3018, 0x72,
    0x3020, 0x93,
    0x3021, 0x03,
    0x3022, 0x01,
    0x3031, 0x08,///0x0a,
    0x303f, 0x0c,
    0x3305, 0xf1,
    0x3307, 0x04,
    0x3309, 0x29,
    0x3500, 0x00,
    0x3501, 0x61,
    0x3502, 0x00,
    0x3503, 0x64,//0x04,
    0x3504, 0x00,
    0x3505, 0x00,
    0x3506, 0x00,
    0x3507, 0x00,
    0x3508, 0x07, // 8X
    0x3509, 0x78, // 80
    0x350a, 0x00,
    0x350b, 0x00,
    0x350c, 0x00,
    0x350d, 0x00,
    0x350e, 0x00,
    0x350f, 0x80,
    0x3510, 0x00,
    0x3511, 0x00,
    0x3512, 0x00,
    0x3513, 0x00,
    0x3514, 0x00,
    0x3515, 0x80,
    0x3516, 0x00,
    0x3517, 0x00,
    0x3518, 0x00,
    0x3519, 0x00,
    0x351a, 0x00,
    0x351b, 0x80,
    0x351c, 0x00,
    0x351d, 0x00,
    0x351e, 0x00,
    0x351f, 0x00,
    0x3520, 0x00,
    0x3521, 0x80,
    0x3522, 0x08,
    0x3524, 0x08,
    0x3526, 0x08,
    0x3528, 0x08,
    0x352a, 0x08,
    0x3602, 0x00,
    0x3603, 0x40,
    0x3604, 0x02,
    0x3605, 0x00,
    0x3606, 0x00,
    0x3607, 0x00,
    0x3609, 0x12,
    0x360a, 0x40,
    0x360c, 0x08,
    //0x360f, 0xe5,
    //0x360f, 0xdb,
    0x360f, 0xe0,
    0x3608, 0x8f,
    0x3611, 0x00,
    0x3613, 0xf7,
    0x3616, 0x58,
    0x3619, 0x99,
    0x361b, 0x60,
    0x361c, 0x7a,
    0x361e, 0x79,
    0x361f, 0x02,
    0x3632, 0x00,
    0x3633, 0x10,
    0x3634, 0x10,
    0x3635, 0x10,
	//0x3636, 0x15,
    0x3636, 0x10,
    0x3646, 0x86,
    0x364a, 0x0b,
    0x3700, 0x17,
    0x3701, 0x22,
    0x3703, 0x10,
    0x370a, 0x37,
    0x3705, 0x00,
    0x3706, 0x63,
    0x3709, 0x3c,
    0x370b, 0x01,
    0x370c, 0x30,
    0x3710, 0x24,
    0x3711, 0x0c,
    0x3716, 0x00,
    0x3720, 0x28,
    0x3729, 0x7b,
    0x372a, 0x84,
    0x372b, 0xbd,
    0x372c, 0xbc,
    0x372e, 0x52,
    0x373c, 0x0e,
    0x373e, 0x33,
    0x3743, 0x10,
    0x3744, 0x88,
    0x3745, 0xc0,
    0x374a, 0x43,
    0x374c, 0x00,
    0x374e, 0x23,
    0x3751, 0x7b,
    0x3752, 0x84,
    0x3753, 0xbd,
    0x3754, 0xbc,
    0x3756, 0x52,
    0x375c, 0x00,
    0x3760, 0x00,
    0x3761, 0x00,
    0x3762, 0x00,
    0x3763, 0x00,
    0x3764, 0x00,
    0x3767, 0x04,
    0x3768, 0x04,
    0x3769, 0x08,
    0x376a, 0x08,
    0x376b, 0x20,
    0x376c, 0x00,
    0x376d, 0x00,
    0x376e, 0x00,
    0x3773, 0x00,
    0x3774, 0x51,
    0x3776, 0xbd,
    0x3777, 0xbd,
    0x3781, 0x18,
    0x3783, 0x25,
    0x3798, 0x1b,
    0x3800, 0x00,
    0x3801, 0x06,
    0x3802, 0x00,
    0x3803, 0x02,
    0x3804, 0x0a,
    0x3805, 0x99,
    0x3806, 0x05,
    0x3807, 0xfd,
    0x3808, 0x0a,
    0x3809, 0x84,
    0x380a, 0x05,
    0x380b, 0xf4,
#if (ADD_VTS)
    0x380c, 0x04, //1250
    0x380d, 0xE2, 
    0x380e, 0x06, //1600
    0x380f, 0x40,    
#else
    0x380c, 0x05, //1280
    0x380d, 0x00, 
    0x380e, 0x06, //1562
    0x380f, 0x1a,
#endif    
    0x3810, 0x00,
    0x3811, 0x08,
    0x3812, 0x00,
    0x3813, 0x04,
    0x3814, 0x01,
    0x3815, 0x01,
    0x3819, 0x01,
#if SENSOR_ROTATE_180
    0x3820, 0x06, // Tom: 0x00: No Flip, 0x06: Row & Column Flip
    0x3821, 0x00, // Tom: 0x06: No Flip, 0x00: Row & Column Flip
#else
    0x3820, 0x00,
    0x3821, 0x06,
#endif
    0x3829, 0x00,
    0x382a, 0x01,
    0x382b, 0x01,
    0x382d, 0x7f,
    0x3830, 0x04,
    0x3836, 0x01,
    0x3837, 0x00,
    0x3841, 0x02,
    0x3846, 0x08,
    0x3847, 0x07,
    0x3d85, 0x36,
    0x3d8c, 0x71,
    0x3d8d, 0xcb,
    0x3f0a, 0x00,
    0x4000, 0xF1,//0x71,
    0x4001, 0x40,
    0x4002, 0x04,
    0x4003, 0x14,
    0x400e, 0x00,
    0x4011, 0x00,
    0x401a, 0x00,
    0x401b, 0x00,
    0x401c, 0x00,
    0x401d, 0x00,
    0x401f, 0x00,
    0x4020, 0x00,
    0x4021, 0x10,
    0x4022, 0x07,
    0x4023, 0xcf,
    0x4024, 0x09,
    0x4025, 0x60,
    0x4026, 0x09,
    0x4027, 0x6f,
    0x4028, 0x00,
    0x4029, 0x02,
    0x402a, 0x06,
    0x402b, 0x04,
    0x402c, 0x02,
    0x402d, 0x02,
    0x402e, 0x0e,
    0x402f, 0x04,
    0x4302, 0xff,
    0x4303, 0xff,
    0x4304, 0x00,
    0x4305, 0x00,
    0x4306, 0x00,
    0x4308, 0x02,
    0x4500, 0x6c,
    0x4501, 0xc4,
    0x4502, 0x40,
    0x4503, 0x01,
    0x4601, 0xA7,
    0x4800, 0x04,
    0x4813, 0x08,
    0x481f, 0x40,
    0x4829, 0x78,
    0x4837, 0x19,///0x2c, // 18
    0x4b00, 0x2a,
    0x4b0d, 0x00,
    0x4d00, 0x04,
    0x4d01, 0x42,
    0x4d02, 0xd1,
    0x4d03, 0x93,
    0x4d04, 0xf5,
    0x4d05, 0xc1,
    0x5000, 0xf3,
    0x5001, 0x11,
    0x5004, 0x00,
    0x500a, 0x00,
    0x500b, 0x00,
    0x5032, 0x00,
    
#if (TEST_PATTERN_EN)
    0x5040, 0x80, // PRE_CONTROL00, 0x00, RW
                  // Bit[7]:   Test pattern enable
                  //           0: disable
                  //           1: enable
                  // Bit[6]:   Rolling bar enable
                  //           0: disable
                  //           1: enable
                  // Bit[5]:   Tansparent enable
                  //           0: disable
                  //           1: enable
                  // Bit[4]:   Square enable
                  //           0: Color square
                  //           1: Black-white square
                  // Bit[3:2]: Color style
                  //           00: Standard color bar
                  //           01: Top-bottom darker color bar
                  //           10: Right-left darker color bar
                  //           11: Bottom-top darker color bar
                  // Bit[1:0]: Test pattern mode
                  //           00: Color bar
                  //           01: Random data
                  //           10: Square
                  //           01: Black image
    0x5041, 0x00, // PRE_CONTROL01, 0x41, RW
                  // Bit[6]:   Window cut enable
                  //           0: disable
                  //           1: enable
                  // Bit[4]:   Same seed enable
                  //           When set, the seed used to generate the
                  //           random data are same which is set in
                  //           seed register
                  // Bit[3:0]: Seed
                  //           Seed used in generating random data
#else
    0x5040, 0x00,
#endif
    0x5050, 0x0c,
    0x5500, 0x00,
    0x5501, 0x10,
    0x5502, 0x01,
    0x5503, 0x0f,
    0x8000, 0x00,
    0x8001, 0x00,
    0x8002, 0x00,
    0x8003, 0x00,
    0x8004, 0x00,
    0x8005, 0x00,
    0x8006, 0x00,
    0x8007, 0x00,
    0x8008, 0x00,
    0x3638, 0x00,
    0x0100, 0x01,
#endif
};

//*** FHD@30fps (Index 2)
static ISP_UINT16 SNR_OV4689_Reg_2688x1520_30P[] = 
{
#if (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
    // Initial Setting 2688x1520_30fps_768Mbps_2lane
    0x0103, 0x01,
    0x3638, 0x00,
    0x0300, 0x00,
    0x0302, 0x20,// for MIPI data rate=768Mbps
    0x0303, 0x00,
    0x0304, 0x03,
    0x030b, 0x00,
    0x030d, 0x1e,
    0x030e, 0x04,
    0x030f, 0x01,
    0x0312, 0x01,
    0x031e, 0x00,
    0x3000, 0x20,
    0x3002, 0x00,
    0x3018, 0x32,
    0x3020, 0x93,
    0x3021, 0x03,
    0x3022, 0x01,
    0x3031, 0x0a,
    0x303f, 0x0c,
    0x3305, 0xf1,
    0x3307, 0x04,
    0x3309, 0x29,
    0x3500, 0x00,
    0x3501, 0x60,
    0x3502, 0x00,
    0x3503, 0x04,
    0x3504, 0x00,
    0x3505, 0x00,
    0x3506, 0x00,
    0x3507, 0x00,
    0x3508, 0x00,
    0x3509, 0x80,
    0x350a, 0x00,
    0x350b, 0x00,
    0x350c, 0x00,
    0x350d, 0x00,
    0x350e, 0x00,
    0x350f, 0x80,
    0x3510, 0x00,
    0x3511, 0x00,
    0x3512, 0x00,
    0x3513, 0x00,
    0x3514, 0x00,
    0x3515, 0x80,
    0x3516, 0x00,
    0x3517, 0x00,
    0x3518, 0x00,
    0x3519, 0x00,
    0x351a, 0x00,
    0x351b, 0x80,
    0x351c, 0x00,
    0x351d, 0x00,
    0x351e, 0x00,
    0x351f, 0x00,
    0x3520, 0x00,
    0x3521, 0x80,
    0x3522, 0x08,
    0x3524, 0x08,
    0x3526, 0x08,
    0x3528, 0x08,
    0x352a, 0x08,
    0x3602, 0x00,
    0x3603, 0x40,
    0x3604, 0x02,
    0x3605, 0x00,
    0x3606, 0x00,
    0x3607, 0x00,
    0x3609, 0x12,
    0x360a, 0x40,
    0x360c, 0x08,
    0x360f, 0xe0,
    0x3608, 0x8f,
    0x3611, 0x00,
    0x3613, 0xf7,
    0x3616, 0x58,
    0x3619, 0x99,
    0x361b, 0x60,
    0x361c, 0x7a,
    0x361e, 0x79,
    0x361f, 0x02,
    0x3632, 0x00,
    0x3633, 0x10,
    0x3634, 0x10,
    0x3635, 0x10,
    0x3636, 0x10,
    0x3646, 0x86,
    0x364a, 0x0b,
    0x3700, 0x17,
    0x3701, 0x22,
    0x3703, 0x10,
    0x370a, 0x37,
    0x3705, 0x00,
    0x3706, 0x63,
    0x3709, 0x3c,
    0x370b, 0x01,
    0x370c, 0x30,
    0x3710, 0x24,
    0x3711, 0x0c,
    0x3716, 0x00,
    0x3720, 0x28,
    0x3729, 0x7b,
    0x372a, 0x84,
    0x372b, 0xbd,
    0x372c, 0xbc,
    0x372e, 0x52,
    0x373c, 0x0e,
    0x373e, 0x33,
    0x3743, 0x10,
    0x3744, 0x88,
    0x3745, 0xc0,
    0x374a, 0x43,
    0x374c, 0x00,
    0x374e, 0x23,
    0x3751, 0x7b,
    0x3752, 0x84,
    0x3753, 0xbd,
    0x3754, 0xbc,
    0x3756, 0x52,
    0x375c, 0x00,
    0x3760, 0x00,
    0x3761, 0x00,
    0x3762, 0x00,
    0x3763, 0x00,
    0x3764, 0x00,
    0x3767, 0x04,
    0x3768, 0x04,
    0x3769, 0x08,
    0x376a, 0x08,
    0x376b, 0x20,
    0x376c, 0x00,
    0x376d, 0x00,
    0x376e, 0x00,
    0x3773, 0x00,
    0x3774, 0x51,
    0x3776, 0xbd,
    0x3777, 0xbd,
    0x3781, 0x18,
    0x3783, 0x25,
    0x3798, 0x1b,
    0x3800, 0x00,
    0x3801, 0x08,
    0x3802, 0x00,
    0x3803, 0x04,
    0x3804, 0x0a,
    0x3805, 0x97,
    0x3806, 0x05,
    0x3807, 0xfb,
    0x3808, 0x0a,
    0x3809, 0x80,
    0x380a, 0x05,
    0x380b, 0xf0,
    0x380c, 0x0A,
    0x380d, 0x14,
    0x380e, 0x06,
    0x380f, 0x12,
    0x3810, 0x00,
    0x3811, 0x08,
    0x3812, 0x00,
    0x3813, 0x04,
    0x3814, 0x01,
    0x3815, 0x01,
    0x3819, 0x01,
    0x3820, 0x00,
    0x3821, 0x06,
    0x3829, 0x00,
    0x382a, 0x01,
    0x382b, 0x01,
    0x382d, 0x7f,
    0x3830, 0x04,
    0x3836, 0x01,
    0x3837, 0x00,
    0x3841, 0x02,
    0x3846, 0x08,
    0x3847, 0x07,
    0x3d85, 0x36,
    0x3d8c, 0x71,
    0x3d8d, 0xcb,
    0x3f0a, 0x00,
    0x4000, 0xf1,
    0x4001, 0x40,
    0x4002, 0x04,
    0x4003, 0x14,
    0x400e, 0x00,
    0x4011, 0x00,
    0x401a, 0x00,
    0x401b, 0x00,
    0x401c, 0x00,
    0x401d, 0x00,
    0x401f, 0x00,
    0x4020, 0x00,
    0x4021, 0x10,
    0x4022, 0x07,
    0x4023, 0xcf,
    0x4024, 0x09,
    0x4025, 0x60,
    0x4026, 0x09,
    0x4027, 0x6f,
    0x4028, 0x00,
    0x4029, 0x02,
    0x402a, 0x06,
    0x402b, 0x04,
    0x402c, 0x02,
    0x402d, 0x02,
    0x402e, 0x0e,
    0x402f, 0x04,
    0x4302, 0xff,
    0x4303, 0xff,
    0x4304, 0x00,
    0x4305, 0x00,
    0x4306, 0x00,
    0x4308, 0x02,
    0x4500, 0x6c,
    0x4501, 0xc4,
    0x4502, 0x40,
    0x4503, 0x01,
    0x4601, 0xA7,
    0x4800, 0x04,
    0x4813, 0x08,
    0x481f, 0x40,
    0x4829, 0x78,
    0x4837, 0x14,
    0x4b00, 0x2a,
    0x4b0d, 0x00,
    0x4d00, 0x04,
    0x4d01, 0x42,
    0x4d02, 0xd1,
    0x4d03, 0x93,
    0x4d04, 0xf5,
    0x4d05, 0xc1,
    0x5000, 0xf3,
    0x5001, 0x11,
    0x5004, 0x00,
    0x500a, 0x00,
    0x500b, 0x00,
    0x5032, 0x00,
    0x5040, 0x00,
    0x5050, 0x0c,
    0x5500, 0x00,
    0x5501, 0x10,
    0x5502, 0x01,
    0x5503, 0x0f,
    0x8000, 0x00,
    0x8001, 0x00,
    0x8002, 0x00,
    0x8003, 0x00,
    0x8004, 0x00,
    0x8005, 0x00,
    0x8006, 0x00,
    0x8007, 0x00,
    0x8008, 0x00,
    0x3638, 0x00,
    0x0100, 0x01,
#elif (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
/*
 * ----------------------------------------------
 *  MCLK: 24Mhz
 *  resolution: 2692x1524 (8bit)
 *  Mipi: 4 lane
 *  Mipi data rate: 324///360Mbps/Lane
 *  SystemCLK: 120Mhz
 *  FPS: 30 (= SystemCLK / (HTS * VTS))
 *  HTS: 2560 (R380c:R380d)
 *  VTS: 1562 (R380e:R380f)
 *  Tline: 21.33us
 *  Max exp line: 1558 (VTS-4)
 * ---------------------------------------------
 */
 
    0x0103, 0x01,
    0x3638, 0x00,
    0x0300, 0x00,
    0x0302, 0x1b,///0x1e, // 2a
    0x0303, 0x01, // 00
    0x0304, 0x03,
    0x030b, 0x00,
    0x030d, 0x1e,
    0x030e, 0x04,
    0x030f, 0x01,
#ifdef SPECIAL_VERSION_15FPS
    #if SPECIAL_VERSION_15FPS
    0x0311, 0x01,
    #endif
#endif
    0x0312, 0x01,
    0x031e, 0x00,
    0x3000, 0x20,
    0x3002, 0x00,
    0x3018, 0x72,
    0x3020, 0x93,
    0x3021, 0x03,
    0x3022, 0x01,
    0x3031, 0x08,///0x0a,
    0x303f, 0x0c,
    0x3305, 0xf1,
    0x3307, 0x04,
    0x3309, 0x29,
    0x3500, 0x00,
    0x3501, 0x61,
    0x3502, 0x00,
    0x3503, 0x64,//0x04,
    0x3504, 0x00,
    0x3505, 0x00,
    0x3506, 0x00,
    0x3507, 0x00,
    0x3508, 0x07, // 8X
    0x3509, 0x78, // 80
    0x350a, 0x00,
    0x350b, 0x00,
    0x350c, 0x00,
    0x350d, 0x00,
    0x350e, 0x00,
    0x350f, 0x80,
    0x3510, 0x00,
    0x3511, 0x00,
    0x3512, 0x00,
    0x3513, 0x00,
    0x3514, 0x00,
    0x3515, 0x80,
    0x3516, 0x00,
    0x3517, 0x00,
    0x3518, 0x00,
    0x3519, 0x00,
    0x351a, 0x00,
    0x351b, 0x80,
    0x351c, 0x00,
    0x351d, 0x00,
    0x351e, 0x00,
    0x351f, 0x00,
    0x3520, 0x00,
    0x3521, 0x80,
    0x3522, 0x08,
    0x3524, 0x08,
    0x3526, 0x08,
    0x3528, 0x08,
    0x352a, 0x08,
    0x3602, 0x00,
    0x3603, 0x40,
    0x3604, 0x02,
    0x3605, 0x00,
    0x3606, 0x00,
    0x3607, 0x00,
    0x3609, 0x12,
    0x360a, 0x40,
    0x360c, 0x08,
	//0x360f, 0xe5,
    //0x360f, 0xdb,
    0x360f, 0xe0,
    0x3608, 0x8f,
    0x3611, 0x00,
    0x3613, 0xf7,
    0x3616, 0x58,
    0x3619, 0x99,
    0x361b, 0x60,
    0x361c, 0x7a,
    0x361e, 0x79,
    0x361f, 0x02,
    0x3632, 0x00,
    0x3633, 0x10,
    0x3634, 0x10,
    0x3635, 0x10,
	//0x3636, 0x15,
    0x3636, 0x10,
    0x3646, 0x86,
    0x364a, 0x0b,
    0x3700, 0x17,
    0x3701, 0x22,
    0x3703, 0x10,
    0x370a, 0x37,
    0x3705, 0x00,
    0x3706, 0x63,
    0x3709, 0x3c,
    0x370b, 0x01,
    0x370c, 0x30,
    0x3710, 0x24,
    0x3711, 0x0c,
    0x3716, 0x00,
    0x3720, 0x28,
    0x3729, 0x7b,
    0x372a, 0x84,
    0x372b, 0xbd,
    0x372c, 0xbc,
    0x372e, 0x52,
    0x373c, 0x0e,
    0x373e, 0x33,
    0x3743, 0x10,
    0x3744, 0x88,
    0x3745, 0xc0,
    0x374a, 0x43,
    0x374c, 0x00,
    0x374e, 0x23,
    0x3751, 0x7b,
    0x3752, 0x84,
    0x3753, 0xbd,
    0x3754, 0xbc,
    0x3756, 0x52,
    0x375c, 0x00,
    0x3760, 0x00,
    0x3761, 0x00,
    0x3762, 0x00,
    0x3763, 0x00,
    0x3764, 0x00,
    0x3767, 0x04,
    0x3768, 0x04,
    0x3769, 0x08,
    0x376a, 0x08,
    0x376b, 0x20,
    0x376c, 0x00,
    0x376d, 0x00,
    0x376e, 0x00,
    0x3773, 0x00,
    0x3774, 0x51,
    0x3776, 0xbd,
    0x3777, 0xbd,
    0x3781, 0x18,
    0x3783, 0x25,
    0x3798, 0x1b,
    0x3800, 0x00,
    0x3801, 0x06,
    0x3802, 0x00,
    0x3803, 0x02,
    0x3804, 0x0a,
    0x3805, 0x99,
    0x3806, 0x05,
    0x3807, 0xfd,
    0x3808, 0x0a,
    0x3809, 0x84,
    0x380a, 0x05,
    0x380b, 0xf4,
    0x380c, 0x0a, // 03
    0x380d, 0x00, // 5c
    0x380e, 0x06,
    0x380f, 0x1a,
    0x3810, 0x00,
    0x3811, 0x08,
    0x3812, 0x00,
    0x3813, 0x04,
    0x3814, 0x01,
    0x3815, 0x01,
    0x3819, 0x01,
#if SENSOR_ROTATE_180
    0x3820, 0x06, // Tom: 0x00: No Flip, 0x06: Row & Column Flip
    0x3821, 0x00, // Tom: 0x06: No Flip, 0x00: Row & Column Flip
#else
    0x3820, 0x00,
    0x3821, 0x06,
#endif
    0x3829, 0x00,
    0x382a, 0x01,
    0x382b, 0x01,
    0x382d, 0x7f,
    0x3830, 0x04,
    0x3836, 0x01,
    0x3837, 0x00,
    0x3841, 0x02,
    0x3846, 0x08,
    0x3847, 0x07,
    0x3d85, 0x36,
    0x3d8c, 0x71,
    0x3d8d, 0xcb,
    0x3f0a, 0x00,
    0x4000, 0xF1,//0x71,
    0x4001, 0x40,
    0x4002, 0x04,
    0x4003, 0x14,
    0x400e, 0x00,
    0x4011, 0x00,
    0x401a, 0x00,
    0x401b, 0x00,
    0x401c, 0x00,
    0x401d, 0x00,
    0x401f, 0x00,
    0x4020, 0x00,
    0x4021, 0x10,
    0x4022, 0x07,
    0x4023, 0xcf,
    0x4024, 0x09,
    0x4025, 0x60,
    0x4026, 0x09,
    0x4027, 0x6f,
    0x4028, 0x00,
    0x4029, 0x02,
    0x402a, 0x06,
    0x402b, 0x04,
    0x402c, 0x02,
    0x402d, 0x02,
    0x402e, 0x0e,
    0x402f, 0x04,
    0x4302, 0xff,
    0x4303, 0xff,
    0x4304, 0x00,
    0x4305, 0x00,
    0x4306, 0x00,
    0x4308, 0x02,
    0x4500, 0x6c,
    0x4501, 0xc4,
    0x4502, 0x40,
    0x4503, 0x01,
    0x4601, 0xA7,
    0x4800, 0x04,
    0x4813, 0x08,
    0x481f, 0x40,
    0x4829, 0x78,
    0x4837, 0x32,///0x2c, // 18
    0x4b00, 0x2a,
    0x4b0d, 0x00,
    0x4d00, 0x04,
    0x4d01, 0x42,
    0x4d02, 0xd1,
    0x4d03, 0x93,
    0x4d04, 0xf5,
    0x4d05, 0xc1,
    0x5000, 0xf3,
    0x5001, 0x11,
    0x5004, 0x00,
    0x500a, 0x00,
    0x500b, 0x00,
    0x5032, 0x00,
    
#if (TEST_PATTERN_EN)
    0x5040, 0x80, // PRE_CONTROL00, 0x00, RW
                  // Bit[7]:   Test pattern enable
                  //           0: disable
                  //           1: enable
                  // Bit[6]:   Rolling bar enable
                  //           0: disable
                  //           1: enable
                  // Bit[5]:   Tansparent enable
                  //           0: disable
                  //           1: enable
                  // Bit[4]:   Square enable
                  //           0: Color square
                  //           1: Black-white square
                  // Bit[3:2]: Color style
                  //           00: Standard color bar
                  //           01: Top-bottom darker color bar
                  //           10: Right-left darker color bar
                  //           11: Bottom-top darker color bar
                  // Bit[1:0]: Test pattern mode
                  //           00: Color bar
                  //           01: Random data
                  //           10: Square
                  //           01: Black image
    0x5041, 0x00, // PRE_CONTROL01, 0x41, RW
                  // Bit[6]:   Window cut enable
                  //           0: disable
                  //           1: enable
                  // Bit[4]:   Same seed enable
                  //           When set, the seed used to generate the
                  //           random data are same which is set in
                  //           seed register
                  // Bit[3:0]: Seed
                  //           Seed used in generating random data
#else
    0x5040, 0x00,
#endif
    0x5050, 0x0c,
    0x5500, 0x00,
    0x5501, 0x10,
    0x5502, 0x01,
    0x5503, 0x0f,
    0x8000, 0x00,
    0x8001, 0x00,
    0x8002, 0x00,
    0x8003, 0x00,
    0x8004, 0x00,
    0x8005, 0x00,
    0x8006, 0x00,
    0x8007, 0x00,
    0x8008, 0x00,
    0x3638, 0x00,
    0x0100, 0x01,
#endif
};

static ISP_UINT16 SNR_OV4689_Reg_2032x1524_30P[] = 
{
#if (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
/*
 * @@ RES_2032x1524@30
 */

/*
 * ---------------------------------------------
 *  MCLK: 24Mhz
 *  resolution: 2032x1524
 *  Mipi : 4 lane
 *  Mipi data rate: 360Mbps/Lane
 *  SystemCLK: 120Mhz
 *  FPS: 30
 *  HTS: 2560(R380c:R380d)
 *  VTS: 1562(R380e:R380f)
 *  Tline: 21.33us
 *  Max exp line: 1558 (VTS-4)
 * ---------------------------------------------
 */
    0x0103, 0x001,
    0x3638, 0x000,
    0x0300, 0x000,
    0x0302, 0x01e,
    0x0303, 0x001,
    0x0304, 0x003,
    0x030b, 0x000,
    0x030d, 0x01e,
    0x030e, 0x004,
    0x030f, 0x001,
    0x0312, 0x001,
    0x031e, 0x000,
    0x3000, 0x020,
    0x3002, 0x000,
    0x3018, 0x072,
    0x3020, 0x093,
    0x3021, 0x003,
    0x3022, 0x001,
    0x3031, 0x00a,
    0x303f, 0x00c,
    0x3305, 0x0f1,
    0x3307, 0x004,
    0x3309, 0x029,
    0x3500, 0x000,
    0x3501, 0x061,
    0x3502, 0x000,
    0x3503, 0x004,
    0x3504, 0x000,
    0x3505, 0x000,
    0x3506, 0x000,
    0x3507, 0x000,
    0x3508, 0x007,
    0x3509, 0x078,
    0x350a, 0x000,
    0x350b, 0x000,
    0x350c, 0x000,
    0x350d, 0x000,
    0x350e, 0x000,
    0x350f, 0x080,
    0x3510, 0x000,
    0x3511, 0x000,
    0x3512, 0x000,
    0x3513, 0x000,
    0x3514, 0x000,
    0x3515, 0x080,
    0x3516, 0x000,
    0x3517, 0x000,
    0x3518, 0x000,
    0x3519, 0x000,
    0x351a, 0x000,
    0x351b, 0x080,
    0x351c, 0x000,
    0x351d, 0x000,
    0x351e, 0x000,
    0x351f, 0x000,
    0x3520, 0x000,
    0x3521, 0x080,
    0x3522, 0x008,
    0x3524, 0x008,
    0x3526, 0x008,
    0x3528, 0x008,
    0x352a, 0x008,
    0x3602, 0x000,
    0x3603, 0x040,
    0x3604, 0x002,
    0x3605, 0x000,
    0x3606, 0x000,
    0x3607, 0x000,
    0x3609, 0x012,
    0x360a, 0x040,
    0x360c, 0x008,
	//0x360f, 0xe5,
    //0x360f, 0xdb,
    0x360f, 0xe0,
    0x3608, 0x08f,
    0x3611, 0x000,
    0x3613, 0x0f7,
    0x3616, 0x058,
    0x3619, 0x099,
    0x361b, 0x060,
    0x361c, 0x07a,
    0x361e, 0x079,
    0x361f, 0x002,
    0x3632, 0x000,
    0x3633, 0x010,
    0x3634, 0x010,
    0x3635, 0x010,
	//0x3636, 0x15,
    0x3636, 0x10,
    0x3646, 0x086,
    0x364a, 0x00b,
    0x3700, 0x017,
    0x3701, 0x022,
    0x3703, 0x010,
    0x370a, 0x037,
    0x3705, 0x000,
    0x3706, 0x063,
    0x3709, 0x03c,
    0x370b, 0x001,
    0x370c, 0x030,
    0x3710, 0x024,
    0x3711, 0x00c,
    0x3716, 0x000,
    0x3720, 0x028,
    0x3729, 0x07b,
    0x372a, 0x084,
    0x372b, 0x0bd,
    0x372c, 0x0bc,
    0x372e, 0x052,
    0x373c, 0x00e,
    0x373e, 0x033,
    0x3743, 0x010,
    0x3744, 0x088,
    0x3745, 0x0c0,
    0x374a, 0x043,
    0x374c, 0x000,
    0x374e, 0x023,
    0x3751, 0x07b,
    0x3752, 0x084,
    0x3753, 0x0bd,
    0x3754, 0x0bc,
    0x3756, 0x052,
    0x375c, 0x000,
    0x3760, 0x000,
    0x3761, 0x000,
    0x3762, 0x000,
    0x3763, 0x000,
    0x3764, 0x000,
    0x3767, 0x004,
    0x3768, 0x004,
    0x3769, 0x008,
    0x376a, 0x008,
    0x376b, 0x020,
    0x376c, 0x000,
    0x376d, 0x000,
    0x376e, 0x000,
    0x3773, 0x000,
    0x3774, 0x051,
    0x3776, 0x0bd,
    0x3777, 0x0bd,
    0x3781, 0x018,
    0x3783, 0x025,
    0x3798, 0x01b,
    0x3800, 0x001,   //Xstart
    0x3801, 0x050,
    0x3802, 0x000,   //Ystart
    0x3803, 0x002,
    0x3804, 0x009,	//XEnd
    0x3805, 0x04f,
    0x3806, 0x005,	//YEnd
    0x3807, 0x0fd,
    0x3808, 0x007, 	//XSize
    0x3809, 0x0f0,
    0x380a, 0x005, 	//YSize
    0x380b, 0x0f4,
    0x380c, 0x00a,
    0x380d, 0x000,
    0x380e, 0x006,
    0x380f, 0x01a,
    0x3810, 0x000,
    0x3811, 0x008,
    0x3812, 0x000,
    0x3813, 0x004,
    0x3814, 0x001,
    0x3815, 0x001,
    0x3819, 0x001,
#if SENSOR_ROTATE_180
    0x3820, 0x06, // Tom: 0x00: No Flip, 0x06: Row & Column Flip
    0x3821, 0x00, // Tom: 0x06: No Flip, 0x00: Row & Column Flip
#else
    0x3820, 0x000,
    0x3821, 0x006,
#endif
    0x3829, 0x000,
    0x382a, 0x001,
    0x382b, 0x001,
    0x382d, 0x07f,
    0x3830, 0x004,
    0x3836, 0x001,
    0x3837, 0x000,
    0x3841, 0x002,
    0x3846, 0x008,
    0x3847, 0x007,
    0x3d85, 0x036,
    0x3d8c, 0x071,
    0x3d8d, 0x0cb,
    0x3f0a, 0x000,
    0x4000, 0x071,
    0x4001, 0x040,
    0x4002, 0x004,
    0x4003, 0x014,
    0x400e, 0x000,
    0x4011, 0x000,
    0x401a, 0x000,
    0x401b, 0x000,
    0x401c, 0x000,
    0x401d, 0x000,
    0x401f, 0x000,
    0x4020, 0x000,
    0x4021, 0x010,
    0x4022, 0x006,
    0x4023, 0x083,
    0x4024, 0x007,
    0x4025, 0x0b0,
    0x4026, 0x007,
    0x4027, 0x0c0,
    0x4028, 0x000,
    0x4029, 0x002,
    0x402a, 0x006,
    0x402b, 0x004,
    0x402c, 0x002,
    0x402d, 0x002,
    0x402e, 0x00e,
    0x402f, 0x004,
    0x4302, 0x0ff,
    0x4303, 0x0ff,
    0x4304, 0x000,
    0x4305, 0x000,
    0x4306, 0x000,
    0x4308, 0x002,
    0x4500, 0x06c,
    0x4501, 0x0c4,
    0x4502, 0x040,
    0x4503, 0x001,
    0x4601, 0x07e,
    0x4800, 0x004,
    0x4813, 0x008,
    0x481f, 0x040,
    0x4829, 0x078,
    0x4837, 0x02c,
    0x4b00, 0x02a,
    0x4b0d, 0x000,
    0x4d00, 0x004,
    0x4d01, 0x042,
    0x4d02, 0x0d1,
    0x4d03, 0x093,
    0x4d04, 0x0f5,
    0x4d05, 0x0c1,
    0x5000, 0x0f3,
    0x5001, 0x011,
    0x5004, 0x000,
    0x500a, 0x000,
    0x500b, 0x000,
    0x5032, 0x000,
    
#if (TEST_PATTERN_EN)
    0x5040, 0x80, // PRE_CONTROL00, 0x00, RW
                  // Bit[7]:   Test pattern enable
                  //           0: disable
                  //           1: enable
                  // Bit[6]:   Rolling bar enable
                  //           0: disable
                  //           1: enable
                  // Bit[5]:   Tansparent enable
                  //           0: disable
                  //           1: enable
                  // Bit[4]:   Square enable
                  //           0: Color square
                  //           1: Black-white square
                  // Bit[3:2]: Color style
                  //           00: Standard color bar
                  //           01: Top-bottom darker color bar
                  //           10: Right-left darker color bar
                  //           11: Bottom-top darker color bar
                  // Bit[1:0]: Test pattern mode
                  //           00: Color bar
                  //           01: Random data
                  //           10: Square
                  //           01: Black image
    0x5041, 0x00, // PRE_CONTROL01, 0x41, RW
                  // Bit[6]:   Window cut enable
                  //           0: disable
                  //           1: enable
                  // Bit[4]:   Same seed enable
                  //           When set, the seed used to generate the
                  //           random data are same which is set in
                  //           seed register
                  // Bit[3:0]: Seed
                  //           Seed used in generating random data
#else
    0x5040, 0x000,
#endif
    0x5050, 0x00c,
    0x5500, 0x000,
    0x5501, 0x010,
    0x5502, 0x001,
    0x5503, 0x00f,
    0x8000, 0x000,
    0x8001, 0x000,
    0x8002, 0x000,
    0x8003, 0x000,
    0x8004, 0x000,
    0x8005, 0x000,
    0x8006, 0x000,
    0x8007, 0x000,
    0x8008, 0x000,
    0x3638, 0x000,
    0x0100, 0x001,
    SENSOR_DELAY_REG, 100, // delay
#endif
};

static ISP_UINT16 SNR_OV4689_Reg_1280x960_30P[] = 
{
#if (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#endif
};

static ISP_UINT16 SNR_OV4689_Reg_1920x1080_30P[] = 
{
#if (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
    0x0103, 0x01,
    0x3638, 0x00,
    0x0300, 0x00,
    0x0302, 0x1e, // 0x2a
    0x0303, 0x01, // 0x00
    0x0304, 0x03,
    0x030b, 0x00,
    0x030d, 0x1e,
    0x030e, 0x04,
    0x030f, 0x01,
    0x0312, 0x01,
    0x031e, 0x00,
    0x3000, 0x20,
    0x3002, 0x00,
 
    0x3018, 0x32,// 0x72, // 0x32/0x72 // 2lane/4lane
    0x3019, 0x0c,//0x00, // 0x0c/0x00 // 2lane/4lane
    0x3020, 0x93,
    0x3021, 0x03,
    0x3022, 0x01,
    0x3031, 0x0a,
    0x303f, 0x0c,
    0x3305, 0xf1,
    0x3307, 0x04,
    0x3309, 0x29,
    0x3500, 0x00,
    0x3501, 0x46, // 0x61
    0x3502, 0x80, // 0x00
    0x3503, 0x04,
    0x3504, 0x00,
    0x3505, 0x00,
    0x3506, 0x00,
    0x3507, 0x00,
    0x3508, 0x07, // 0x8X
    0x3509, 0x78, // 0x80
    0x350a, 0x00,
    0x350b, 0x00,
    0x350c, 0x00,
    0x350d, 0x00,
    0x350e, 0x00,
    0x350f, 0x80,
    0x3510, 0x00,
    0x3511, 0x00,
    0x3512, 0x00,
    0x3513, 0x00,
    0x3514, 0x00,
    0x3515, 0x80,
    0x3516, 0x00,
    0x3517, 0x00,
    0x3518, 0x00,
    0x3519, 0x00,
    0x351a, 0x00,
    0x351b, 0x80,
    0x351c, 0x00,
    0x351d, 0x00,
    0x351e, 0x00,
    0x351f, 0x00,
    0x3520, 0x00,
    0x3521, 0x80,
    0x3522, 0x08,
    0x3524, 0x08,
    0x3526, 0x08,
    0x3528, 0x08,
    0x352a, 0x08,
    0x3602, 0x00,
    0x3603, 0x40,
    0x3604, 0x02,
    0x3605, 0x00,
    0x3606, 0x00,
    0x3607, 0x00,
    0x3609, 0x12,
    0x360a, 0x40,
    0x360c, 0x08,
	//0x360f, 0xe5,
  	0x360f, 0xdb,
    0x3608, 0x8f,
    0x3611, 0x00,
    0x3613, 0xf7,
    0x3616, 0x58,
    0x3619, 0x99,
    0x361b, 0x60,
    0x361c, 0x7a,
    0x361e, 0x79,
    0x361f, 0x02,
    0x3632, 0x00,
    0x3633, 0x10,
    0x3634, 0x10,
    //0x3636, 0x15,
    0x3636, 0x10,
    0x3635, 0x10,
    0x3646, 0x86,
    0x364a, 0x0b,
    0x3700, 0x17,
    0x3701, 0x22,
    0x3703, 0x10,
    0x370a, 0x37,
    0x3705, 0x00,
    0x3706, 0x63,
    0x3709, 0x3c,
    0x370b, 0x01,
    0x370c, 0x30,
    0x3710, 0x24,
    0x3711, 0x0c,
    0x3716, 0x00,
    0x3720, 0x28,
    0x3729, 0x7b,
    0x372a, 0x84,
    0x372b, 0xbd,
    0x372c, 0xbc,
    0x372e, 0x52,
    0x373c, 0x0e,
    0x373e, 0x33,
    0x3743, 0x10,
    0x3744, 0x88,
    0x3745, 0xc0,
    0x374a, 0x43,
    0x374c, 0x00,
    0x374e, 0x23,
    0x3751, 0x7b,
    0x3752, 0x84,
    0x3753, 0xbd,
    0x3754, 0xbc,
    0x3756, 0x52,
    0x375c, 0x00,
    0x3760, 0x00,
    0x3761, 0x00,
    0x3762, 0x00,
    0x3763, 0x00,
    0x3764, 0x00,
    0x3767, 0x04,
    0x3768, 0x04,
    0x3769, 0x08,
    0x376a, 0x08,
    0x376b, 0x20,
    0x376c, 0x00,
    0x376d, 0x00,
    0x376e, 0x00,
    0x3773, 0x00,
    0x3774, 0x51,
    0x3776, 0xbd,
    0x3777, 0xbd,
    0x3781, 0x18,
    0x3783, 0x25,
    0x3798, 0x1b,
    0x3800, 0x01,
    0x3801, 0x84, // 0x24
    0x3802, 0x00,
    0x3803, 0xda, // 0xa6
    0x3804, 0x09,
    0x3805, 0x1b, // 0x7b
    0x3806, 0x05,
    0x3807, 0x25, // 0x59
    0x3808, 0x07, // 0x08
    0x3809, 0x88, // 0x48
    0x380a, 0x04,
    0x380b, 0x44, // 0xac
    0x380c, 0x0d, // 0x0a // 0x14 // 0x0a // 0x03
    0x380d, 0xbc, // 0x04 // 0xf6 // 0x30 // 0x18 // 0x5c
    0x380e, 0x04, // 0x06
    0x380f, 0x70, // 0x1c // 0x20 // 0x12
    0x3810, 0x00,
    0x3811, 0x08,
    0x3812, 0x00,
    0x3813, 0x04,
    0x3814, 0x01,
    0x3815, 0x01,
    0x3819, 0x01,
#if 1//SENSOR_ROTATE_180
    0x3820, 0x06, // Tom: 0x00: No Flip, 0x06: Row & Column Flip
    0x3821, 0x00, // Tom: 0x06: No Flip, 0x00: Row & Column Flip
#else
    0x3820, 0x00,
    0x3821, 0x06,
#endif
    0x3829, 0x00,
    0x382a, 0x01,
    0x382b, 0x01,
    0x382d, 0x7f,
    0x3830, 0x04,
    0x3836, 0x01,
    0x3837, 0x00,
    0x3841, 0x02,
    0x3846, 0x08,
    0x3847, 0x07,
    0x3d85, 0x36,
    0x3d8c, 0x71,
    0x3d8d, 0xcb,
    0x3f0a, 0x00,
    0x4000, 0x71,
    0x4001, 0x40,
    0x4002, 0x04,
    0x4003, 0x14,
    0x400e, 0x00,
    0x4011, 0x00,
    0x401a, 0x00,
    0x401b, 0x00,
    0x401c, 0x00,
    0x401d, 0x00,
    0x401f, 0x00,
    0x4020, 0x00,
    0x4021, 0x10,
    0x4022, 0x06,
    0x4023, 0x1b, // 0x3f
    0x4024, 0x07,
    0x4025, 0x48, // 0x6c
    0x4026, 0x07,
    0x4027, 0x58, // 0x7b
    0x4028, 0x00,
    0x4029, 0x02,
    0x402a, 0x06,
    0x402b, 0x04,
    0x402c, 0x02,
    0x402d, 0x02,
    0x402e, 0x0e,
    0x402f, 0x04,
    0x4302, 0xff,
    0x4303, 0xff,
    0x4304, 0x00,
    0x4305, 0x00,
    0x4306, 0x00,
    0x4308, 0x02,
    0x4500, 0x6c,
    0x4501, 0xc4,
    0x4502, 0x40,
    0x4503, 0x01,
    0x4601, 0x77,
    0x4800, 0x04,
    0x4813, 0x08,
    0x481f, 0x40,
    0x4829, 0x78,
    0x4837, 0x16,//0x2c, // 0x18
    0x4b00, 0x2a,
    0x4b0d, 0x00,
    0x4d00, 0x04,
    0x4d01, 0x42,
    0x4d02, 0xd1,
    0x4d03, 0x93,
    0x4d04, 0xf5,
    0x4d05, 0xc1,
    0x5000, 0xf3,
    0x5001, 0x11,
    0x5004, 0x00,
    0x500a, 0x00,
    0x500b, 0x00,
    0x5032, 0x00,

    0x5040, 0x00,

    0x5050, 0x0c,
    0x5500, 0x00,
    0x5501, 0x10,
    0x5502, 0x01,
    0x5503, 0x0f,
    0x8000, 0x00,
    0x8001, 0x00,
    0x8002, 0x00,
    0x8003, 0x00,
    0x8004, 0x00,
    0x8005, 0x00,
    0x8006, 0x00,
    0x8007, 0x00,
    0x8008, 0x00,
    0x3638, 0x00,
    0x0100, 0x01
#elif (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
/*
 * @@ RES_1928x1092_30fps
 * 100 99 1928 1092
 * 102 3601 bb8
 */

/*
 * ---------------------------------------------
 *  MCLK: 24Mhz
 *  resolution: 1928x1092
 *  Mipi : 4 lane
 *  Mipi data rate: 360Mbps/Lane
 *  SystemCLK: 120Mhz
 *  FPS: 30
 *  HTS: 3516 (R380c:R380d)
 *  VTS: 1136 (R380e:R380f)
 *  Tline: 29.3us
 *  Max exp line: 1128 (VTS-8)
 * ---------------------------------------------
 */

    0x0103, 0x01,
    0x3638, 0x00,
    0x0300, 0x00,
    0x0302, 0x1e, // 0x2a
    0x0303, 0x01, // 0x00
    0x0304, 0x03,
    0x030b, 0x00,
    0x030d, 0x1e,
    0x030e, 0x04,
    0x030f, 0x01,
    0x0312, 0x01,
    0x031e, 0x00,
    0x3000, 0x20,
    0x3002, 0x00,
    0x3018, 0x72, // 0x32/0x72 2lane/4lane
    0x3019, 0x00, // 0x0c/0x00 2lane/4lane
    0x3020, 0x93,
    0x3021, 0x03,
    0x3022, 0x01,
    0x3031, 0x0a,
    0x303f, 0x0c,
    0x3305, 0xf1,
    0x3307, 0x04,
    0x3309, 0x29,
    0x3500, 0x00,
    0x3501, 0x46, // 0x61
    0x3502, 0x80, // 0x00
    0x3503, 0x04,
    0x3504, 0x00,
    0x3505, 0x00,
    0x3506, 0x00,
    0x3507, 0x00,
    0x3508, 0x07, // 0x8X
    0x3509, 0x78, // 0x80
    0x350a, 0x00,
    0x350b, 0x00,
    0x350c, 0x00,
    0x350d, 0x00,
    0x350e, 0x00,
    0x350f, 0x80,
    0x3510, 0x00,
    0x3511, 0x00,
    0x3512, 0x00,
    0x3513, 0x00,
    0x3514, 0x00,
    0x3515, 0x80,
    0x3516, 0x00,
    0x3517, 0x00,
    0x3518, 0x00,
    0x3519, 0x00,
    0x351a, 0x00,
    0x351b, 0x80,
    0x351c, 0x00,
    0x351d, 0x00,
    0x351e, 0x00,
    0x351f, 0x00,
    0x3520, 0x00,
    0x3521, 0x80,
    0x3522, 0x08,
    0x3524, 0x08,
    0x3526, 0x08,
    0x3528, 0x08,
    0x352a, 0x08,
    0x3602, 0x00,
    0x3603, 0x40,
    0x3604, 0x02,
    0x3605, 0x00,
    0x3606, 0x00,
    0x3607, 0x00,
    0x3609, 0x12,
    0x360a, 0x40,
    0x360c, 0x08,
	//0x360f, 0xe5,
  	//0x360f, 0xdb,
    0x360f, 0xe0,
    0x3608, 0x8f,
    0x3611, 0x00,
    0x3613, 0xf7,
    0x3616, 0x58,
    0x3619, 0x99,
    0x361b, 0x60,
    0x361c, 0x7a,
    0x361e, 0x79,
    0x361f, 0x02,
    0x3632, 0x00,
    0x3633, 0x10,
    0x3634, 0x10,
    0x3635, 0x10,
	//0x3636, 0x15,
    0x3636, 0x10,
    0x3646, 0x86,
    0x364a, 0x0b,
    0x3700, 0x17,
    0x3701, 0x22,
    0x3703, 0x10,
    0x370a, 0x37,
    0x3705, 0x00,
    0x3706, 0x63,
    0x3709, 0x3c,
    0x370b, 0x01,
    0x370c, 0x30,
    0x3710, 0x24,
    0x3711, 0x0c,
    0x3716, 0x00,
    0x3720, 0x28,
    0x3729, 0x7b,
    0x372a, 0x84,
    0x372b, 0xbd,
    0x372c, 0xbc,
    0x372e, 0x52,
    0x373c, 0x0e,
    0x373e, 0x33,
    0x3743, 0x10,
    0x3744, 0x88,
    0x3745, 0xc0,
    0x374a, 0x43,
    0x374c, 0x00,
    0x374e, 0x23,
    0x3751, 0x7b,
    0x3752, 0x84,
    0x3753, 0xbd,
    0x3754, 0xbc,
    0x3756, 0x52,
    0x375c, 0x00,
    0x3760, 0x00,
    0x3761, 0x00,
    0x3762, 0x00,
    0x3763, 0x00,
    0x3764, 0x00,
    0x3767, 0x04,
    0x3768, 0x04,
    0x3769, 0x08,
    0x376a, 0x08,
    0x376b, 0x20,
    0x376c, 0x00,
    0x376d, 0x00,
    0x376e, 0x00,
    0x3773, 0x00,
    0x3774, 0x51,
    0x3776, 0xbd,
    0x3777, 0xbd,
    0x3781, 0x18,
    0x3783, 0x25,
    0x3798, 0x1b,
    0x3800, 0x01,	//Xstart
    0x3801, 0x84,
    0x3802, 0x00,   //Ystart
    0x3803, 0xda,
    0x3804, 0x09,	//XEnd
    0x3805, 0x1b,
    0x3806, 0x05,	//YEnd
    0x3807, 0x25,
    0x3808, 0x07, 	//XSize
    0x3809, 0x88,
    0x380a, 0x04, 	//YSize
    0x380b, 0x44,
    0x380c, 0x0d,
    0x380d, 0xbc,
    0x380e, 0x04, // 0x06
    0x380f, 0x70, // 0x1c // 0x20 // 0x12
    0x3810, 0x00,
    0x3811, 0x08,
    0x3812, 0x00,
    0x3813, 0x04,
    0x3814, 0x01,
    0x3815, 0x01,
    0x3819, 0x01,
#if SENSOR_ROTATE_180
    0x3820, 0x06, // Tom: 0x00: No Flip, 0x06: Row & Column Flip
    0x3821, 0x00, // Tom: 0x06: No Flip, 0x00: Row & Column Flip
#else
    0x3820, 0x00,
    0x3821, 0x06,
#endif
    0x3829, 0x00,
    0x382a, 0x01,
    0x382b, 0x01,
    0x382d, 0x7f,
    0x3830, 0x04,
    0x3836, 0x01,
    0x3837, 0x00,
    0x3841, 0x02,
    0x3846, 0x08,
    0x3847, 0x07,
    0x3d85, 0x36,
    0x3d8c, 0x71,
    0x3d8d, 0xcb,
    0x3f0a, 0x00,
    0x4000, 0x71,
    0x4001, 0x40,
    0x4002, 0x04,
    0x4003, 0x14,
    0x400e, 0x00,
    0x4011, 0x00,
    0x401a, 0x00,
    0x401b, 0x00,
    0x401c, 0x00,
    0x401d, 0x00,
    0x401f, 0x00,
    0x4020, 0x00,
    0x4021, 0x10,
    0x4022, 0x06,
    0x4023, 0x1b, // 0x3f
    0x4024, 0x07,
    0x4025, 0x48, // 0x6c
    0x4026, 0x07,
    0x4027, 0x58, // 0x7b
    0x4028, 0x00,
    0x4029, 0x02,
    0x402a, 0x06,
    0x402b, 0x04,
    0x402c, 0x02,
    0x402d, 0x02,
    0x402e, 0x0e,
    0x402f, 0x04,
    0x4302, 0xff,
    0x4303, 0xff,
    0x4304, 0x00,
    0x4305, 0x00,
    0x4306, 0x00,
    0x4308, 0x02,
    0x4500, 0x6c,
    0x4501, 0xc4,
    0x4502, 0x40,
    0x4503, 0x01,
    0x4601, 0x77,
    0x4800, 0x04,
    0x4813, 0x08,
    0x481f, 0x40,
    0x4829, 0x78,
    0x4837, 0x2c, // 0x18
    0x4b00, 0x2a,
    0x4b0d, 0x00,
    0x4d00, 0x04,
    0x4d01, 0x42,
    0x4d02, 0xd1,
    0x4d03, 0x93,
    0x4d04, 0xf5,
    0x4d05, 0xc1,
    0x5000, 0xf3,
    0x5001, 0x11,
    0x5004, 0x00,
    0x500a, 0x00,
    0x500b, 0x00,
    0x5032, 0x00,
    
#if (TEST_PATTERN_EN)
    0x5040, 0x80, // PRE_CONTROL00, 0x00, RW
                  // Bit[7]:   Test pattern enable
                  //           0: disable
                  //           1: enable
                  // Bit[6]:   Rolling bar enable
                  //           0: disable
                  //           1: enable
                  // Bit[5]:   Tansparent enable
                  //           0: disable
                  //           1: enable
                  // Bit[4]:   Square enable
                  //           0: Color square
                  //           1: Black-white square
                  // Bit[3:2]: Color style
                  //           00: Standard color bar
                  //           01: Top-bottom darker color bar
                  //           10: Right-left darker color bar
                  //           11: Bottom-top darker color bar
                  // Bit[1:0]: Test pattern mode
                  //           00: Color bar
                  //           01: Random data
                  //           10: Square
                  //           01: Black image
    0x5041, 0x00, // PRE_CONTROL01, 0x41, RW
                  // Bit[6]:   Window cut enable
                  //           0: disable
                  //           1: enable
                  // Bit[4]:   Same seed enable
                  //           When set, the seed used to generate the
                  //           random data are same which is set in
                  //           seed register
                  // Bit[3:0]: Seed
                  //           Seed used in generating random data
#else
    0x5040, 0x00,
#endif
    0x5050, 0x0c,
    0x5500, 0x00,
    0x5501, 0x10,
    0x5502, 0x01,
    0x5503, 0x0f,
    0x8000, 0x00,
    0x8001, 0x00,
    0x8002, 0x00,
    0x8003, 0x00,
    0x8004, 0x00,
    0x8005, 0x00,
    0x8006, 0x00,
    0x8007, 0x00,
    0x8008, 0x00,
    0x3638, 0x00,
    0x0100, 0x01
#endif
};

static ISP_UINT16 SNR_OV4689_Reg_1920x1080_50P[] = 
{
#if (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#endif
};

static ISP_UINT16 SNR_OV4689_Reg_1920x1080_60P[] = 
{
#if (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
/*
 * @@ RES_1928x1092_60fps
 * 100 99 1928 1092
 * 102 3601 1770
 */

/*
 * ----------------------------------------------
 *  MCLK: 24Mhz
 *  resolution: 1928x1092
 *  Mipi: 4 lane
 *  Mipi data rate: 360Mbps/Lane
 *  SystemCLK: 120Mhz
 *  FPS: 60
 *  HTS: 1760 (R380c:R380d)
 *  VTS: 1136 (R380e:R380f)
 *  Tline: 14.67us
 *  Max exp line: 1128 (VTS-8)
 * ---------------------------------------------
 */

    0x0103, 0x01,
    0x3638, 0x00,
    0x0300, 0x00,
    0x0302, 0x1e, // 0x2a
    0x0303, 0x01, // 0x00
    0x0304, 0x03,
    0x030b, 0x00,
    0x030d, 0x1e,
    0x030e, 0x04,
    0x030f, 0x01,
    0x0312, 0x01,
    0x031e, 0x00,
    0x3000, 0x20,
    0x3002, 0x00,
    0x3018, 0x72, // 0x32/0x72 // 2lane/4lane
    0x3019, 0x00, // 0x0c/0x00 // 2lane/4lane
    0x3020, 0x93,
    0x3021, 0x03,
    0x3022, 0x01,
    0x3031, 0x0a,
    0x303f, 0x0c,
    0x3305, 0xf1,
    0x3307, 0x04,
    0x3309, 0x29,
    0x3500, 0x00,
    0x3501, 0x46, // 0x61
    0x3502, 0x80, // 0x00
    0x3503, 0x04,
    0x3504, 0x00,
    0x3505, 0x00,
    0x3506, 0x00,
    0x3507, 0x00,
    0x3508, 0x07, // 0x8X
    0x3509, 0x78, // 0x80
    0x350a, 0x00,
    0x350b, 0x00,
    0x350c, 0x00,
    0x350d, 0x00,
    0x350e, 0x00,
    0x350f, 0x80,
    0x3510, 0x00,
    0x3511, 0x00,
    0x3512, 0x00,
    0x3513, 0x00,
    0x3514, 0x00,
    0x3515, 0x80,
    0x3516, 0x00,
    0x3517, 0x00,
    0x3518, 0x00,
    0x3519, 0x00,
    0x351a, 0x00,
    0x351b, 0x80,
    0x351c, 0x00,
    0x351d, 0x00,
    0x351e, 0x00,
    0x351f, 0x00,
    0x3520, 0x00,
    0x3521, 0x80,
    0x3522, 0x08,
    0x3524, 0x08,
    0x3526, 0x08,
    0x3528, 0x08,
    0x352a, 0x08,
    0x3602, 0x00,
    0x3603, 0x40,
    0x3604, 0x02,
    0x3605, 0x00,
    0x3606, 0x00,
    0x3607, 0x00,
    0x3609, 0x12,
    0x360a, 0x40,
    0x360c, 0x08,
	//0x360f, 0xe5,
    //0x360f, 0xdb,
    0x360f, 0xe0,
    0x3608, 0x8f,
    0x3611, 0x00,
    0x3613, 0xf7,
    0x3616, 0x58,
    0x3619, 0x99,
    0x361b, 0x60,
    0x361c, 0x7a,
    0x361e, 0x79,
    0x361f, 0x02,
    0x3632, 0x00,
    0x3633, 0x10,
    0x3634, 0x10,
    0x3635, 0x10,
	//0x3636, 0x15,
    0x3636, 0x10,
    0x3646, 0x86,
    0x364a, 0x0b,
    0x3700, 0x17,
    0x3701, 0x22,
    0x3703, 0x10,
    0x370a, 0x37,
    0x3705, 0x00,
    0x3706, 0x63,
    0x3709, 0x3c,
    0x370b, 0x01,
    0x370c, 0x30,
    0x3710, 0x24,
    0x3711, 0x0c,
    0x3716, 0x00,
    0x3720, 0x28,
    0x3729, 0x7b,
    0x372a, 0x84,
    0x372b, 0xbd,
    0x372c, 0xbc,
    0x372e, 0x52,
    0x373c, 0x0e,
    0x373e, 0x33,
    0x3743, 0x10,
    0x3744, 0x88,
    0x3745, 0xc0,
    0x374a, 0x43,
    0x374c, 0x00,
    0x374e, 0x23,
    0x3751, 0x7b,
    0x3752, 0x84,
    0x3753, 0xbd,
    0x3754, 0xbc,
    0x3756, 0x52,
    0x375c, 0x00,
    0x3760, 0x00,
    0x3761, 0x00,
    0x3762, 0x00,
    0x3763, 0x00,
    0x3764, 0x00,
    0x3767, 0x04,
    0x3768, 0x04,
    0x3769, 0x08,
    0x376a, 0x08,
    0x376b, 0x20,
    0x376c, 0x00,
    0x376d, 0x00,
    0x376e, 0x00,
    0x3773, 0x00,
    0x3774, 0x51,
    0x3776, 0xbd,
    0x3777, 0xbd,
    0x3781, 0x18,
    0x3783, 0x25,
    0x3798, 0x1b,
    0x3800, 0x01,	//Xstart
    0x3801, 0x84,
    0x3802, 0x00,   //Ystart
    0x3803, 0xda,
    0x3804, 0x09,	//XEnd
    0x3805, 0x1b,
    0x3806, 0x05,	//YEnd
    0x3807, 0x25,
    0x3808, 0x07,  	//XSize
    0x3809, 0x88,
    0x380a, 0x04, 	//YSize
    0x380b, 0x44,
    0x380c, 0x06,
    0x380d, 0xe0, // 0x04 // 0xf6 // 0x30 // 0x18 // 0x5c
    0x380e, 0x04, // 0x06
    0x380f, 0x70, // 0x1c // 0x20 // 0x12
    0x3810, 0x00,
    0x3811, 0x08,
    0x3812, 0x00,
    0x3813, 0x04,
    0x3814, 0x01,
    0x3815, 0x01,
    0x3819, 0x01,
#if SENSOR_ROTATE_180
    0x3820, 0x06, // Tom: 0x00: No Flip, 0x06: Row & Column Flip
    0x3821, 0x00, // Tom: 0x06: No Flip, 0x00: Row & Column Flip
#else
    0x3820, 0x00,
    0x3821, 0x06,
#endif
    0x3829, 0x00,
    0x382a, 0x01,
    0x382b, 0x01,
    0x382d, 0x7f,
    0x3830, 0x04,
    0x3836, 0x01,
    0x3837, 0x00,
    0x3841, 0x02,
    0x3846, 0x08,
    0x3847, 0x07,
    0x3d85, 0x36,
    0x3d8c, 0x71,
    0x3d8d, 0xcb,
    0x3f0a, 0x00,
    0x4000, 0x71,
    0x4001, 0x40,
    0x4002, 0x04,
    0x4003, 0x14,
    0x400e, 0x00,
    0x4011, 0x00,
    0x401a, 0x00,
    0x401b, 0x00,
    0x401c, 0x00,
    0x401d, 0x00,
    0x401f, 0x00,
    0x4020, 0x00,
    0x4021, 0x10,
    0x4022, 0x06,
    0x4023, 0x1b, // 0x3f
    0x4024, 0x07,
    0x4025, 0x48, // 0x6c
    0x4026, 0x07,
    0x4027, 0x58, // 0x7b
    0x4028, 0x00,
    0x4029, 0x02,
    0x402a, 0x06,
    0x402b, 0x04,
    0x402c, 0x02,
    0x402d, 0x02,
    0x402e, 0x0e,
    0x402f, 0x04,
    0x4302, 0xff,
    0x4303, 0xff,
    0x4304, 0x00,
    0x4305, 0x00,
    0x4306, 0x00,
    0x4308, 0x02,
    0x4500, 0x6c,
    0x4501, 0xc4,
    0x4502, 0x40,
    0x4503, 0x01,
    0x4601, 0x77,
    0x4800, 0x04,
    0x4813, 0x08,
    0x481f, 0x40,
    0x4829, 0x78,
    0x4837, 0x2c, // 0x18
    0x4b00, 0x2a,
    0x4b0d, 0x00,
    0x4d00, 0x04,
    0x4d01, 0x42,
    0x4d02, 0xd1,
    0x4d03, 0x93,
    0x4d04, 0xf5,
    0x4d05, 0xc1,
    0x5000, 0xf3,
    0x5001, 0x11,
    0x5004, 0x00,
    0x500a, 0x00,
    0x500b, 0x00,
    0x5032, 0x00,
    
#if (TEST_PATTERN_EN)
    0x5040, 0x80, // PRE_CONTROL00, 0x00, RW
                  // Bit[7]:   Test pattern enable
                  //           0: disable
                  //           1: enable
                  // Bit[6]:   Rolling bar enable
                  //           0: disable
                  //           1: enable
                  // Bit[5]:   Tansparent enable
                  //           0: disable
                  //           1: enable
                  // Bit[4]:   Square enable
                  //           0: Color square
                  //           1: Black-white square
                  // Bit[3:2]: Color style
                  //           00: Standard color bar
                  //           01: Top-bottom darker color bar
                  //           10: Right-left darker color bar
                  //           11: Bottom-top darker color bar
                  // Bit[1:0]: Test pattern mode
                  //           00: Color bar
                  //           01: Random data
                  //           10: Square
                  //           01: Black image
    0x5041, 0x00, // PRE_CONTROL01, 0x41, RW
                  // Bit[6]:   Window cut enable
                  //           0: disable
                  //           1: enable
                  // Bit[4]:   Same seed enable
                  //           When set, the seed used to generate the
                  //           random data are same which is set in
                  //           seed register
                  // Bit[3:0]: Seed
                  //           Seed used in generating random data
#else
    0x5040, 0x00,
#endif
    0x5050, 0x0c,
    0x5500, 0x00,
    0x5501, 0x10,
    0x5502, 0x01,
    0x5503, 0x0f,
    0x8000, 0x00,
    0x8001, 0x00,
    0x8002, 0x00,
    0x8003, 0x00,
    0x8004, 0x00,
    0x8005, 0x00,
    0x8006, 0x00,
    0x8007, 0x00,
    0x8008, 0x00,
    0x3638, 0x00,
    0x0100, 0x01
#endif
};

static ISP_UINT16 SNR_OV4689_Reg_1920x1080_15P[] = 
{
#if (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#endif
};

ISP_UINT16 SNR_OV4689_Reg_1280x720_30P[] = 
{
#if (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
/*
 * @@ RES_1288x724_2x_Bin_30fps_360Mbps
 *
 * 100 99 1288 724
 * 102 3601 1770
 */

/*
 * ----------------------------------------------
 *  MCLK: 24Mhz
 *  resolution: 1288x724
 *  Mipi: 4 lane
 *  Mipi data rate: 360Mbps/Lane
 *  SystemCLK: 120Mhz
 *  FPS: 29.96 (= SystemCLK / (HTS * VTS))
 *  HTS: 2508 (R380c:R380d)
 *  VTS: 1597 (R380e:R380f)
 *  Tline: 20.9us
 *  Max exp line: 1589 (VTS-8)
 * ---------------------------------------------
 */

    0x0103, 0x01,
    0x3638, 0x00,
    0x0300, 0x00,
    0x0302, 0x1e, // 0x2a
    0x0303, 0x01, // 0x00
    0x0304, 0x03,
    0x030b, 0x00,
    0x030d, 0x1e,
    0x030e, 0x04,
    0x030f, 0x01,
    0x0312, 0x01,
    0x031e, 0x00,
    0x3000, 0x20,
    0x3002, 0x00,
    0x3018, 0x72, // 0x32/0x72 // 2lane/4lane
    0x3019, 0x00, // 0x0c/0x00 // 2lane/4lane
    0x3020, 0x93,
    0x3021, 0x03,
    0x3022, 0x01,
    0x3031, 0x0a,
    0x303f, 0x0c,
    0x3305, 0xf1,
    0x3307, 0x04,
    0x3309, 0x29,
    0x3500, 0x00,
    0x3501, 0x63,
    0x3502, 0x00,
    0x3503, 0x04,
    0x3504, 0x00,
    0x3505, 0x00,
    0x3506, 0x00,
    0x3507, 0x00,
    0x3508, 0x07, // 0x8X
    0x3509, 0x78, 
    0x350a, 0x00,
    0x350b, 0x00,
    0x350c, 0x00,
    0x350d, 0x00,
    0x350e, 0x00,
    0x350f, 0x80,
    0x3510, 0x00,
    0x3511, 0x00,
    0x3512, 0x00,
    0x3513, 0x00,
    0x3514, 0x00,
    0x3515, 0x80,
    0x3516, 0x00,
    0x3517, 0x00,
    0x3518, 0x00,
    0x3519, 0x00,
    0x351a, 0x00,
    0x351b, 0x80,
    0x351c, 0x00,
    0x351d, 0x00,
    0x351e, 0x00,
    0x351f, 0x00,
    0x3520, 0x00,
    0x3521, 0x80,
    0x3522, 0x08,
    0x3524, 0x08,
    0x3526, 0x08,
    0x3528, 0x08,
    0x352a, 0x08,
    0x3602, 0x00,
    0x3603, 0x40,
    0x3604, 0x02,
    0x3605, 0x00,
    0x3606, 0x00,
    0x3607, 0x00,
    0x3609, 0x12,
    0x360a, 0x40,
    0x360c, 0x08,
	//0x360f, 0xe5,
    //0x360f, 0xdb,
    0x360f, 0xe0,
    0x3608, 0x8f,
    0x3611, 0x00,
    0x3613, 0xf7,
    0x3616, 0x58,
    0x3619, 0x99,
    0x361b, 0x60,
    0x361c, 0x7a,
    0x361e, 0x79,
    0x361f, 0x02,
    0x3632, 0x05,
    0x3633, 0x10,
    0x3634, 0x10,
    0x3635, 0x10,
	//0x3636, 0x15,
    0x3636, 0x10,
    0x3646, 0x86,
    0x364a, 0x0b,
    0x3700, 0x17,
    0x3701, 0x22,
    0x3703, 0x10,
    0x370a, 0x37,
    0x3705, 0x00,
    0x3706, 0x63,
    0x3709, 0x3c,
    0x370b, 0x01,
    0x370c, 0x30,
    0x3710, 0x24,
    0x3711, 0x0c,
    0x3716, 0x00,
    0x3720, 0x28,
    0x3729, 0x7b,
    0x372a, 0x84,
    0x372b, 0xbd,
    0x372c, 0xbc,
    0x372e, 0x52,
    0x373c, 0x0e,
    0x373e, 0x33,
    0x3743, 0x10,
    0x3744, 0x88,
    0x3745, 0xc0,
    0x374a, 0x43,
    0x374c, 0x00,
    0x374e, 0x23,
    0x3751, 0x7b,
    0x3752, 0x84,
    0x3753, 0xbd,
    0x3754, 0xbc,
    0x3756, 0x52,
    0x375c, 0x00,
    0x3760, 0x00,
    0x3761, 0x00,
    0x3762, 0x00,
    0x3763, 0x00,
    0x3764, 0x00,
    0x3767, 0x04,
    0x3768, 0x04,
    0x3769, 0x08,
    0x376a, 0x08,
    0x376b, 0x40,
    0x376c, 0x00,
    0x376d, 0x00,
    0x376e, 0x00,
    0x3773, 0x00,
    0x3774, 0x51,
    0x3776, 0xbd,
    0x3777, 0xbd,
    0x3781, 0x18,
    0x3783, 0x25,
    0x3798, 0x1b,
    0x3800, 0x00,	//Xstart
    0x3801, 0x40,
    0x3802, 0x00,   //Ystart
    0x3803, 0x28,
    0x3804, 0x0a,	//XEnd
    0x3805, 0x5f,
    0x3806, 0x05,	//YEnd
    0x3807, 0xD7,
    0x3808, 0x05, 	//XSize
    0x3809, 0x08,
    0x380a, 0x02, 	//YSize
    0x380b, 0xD4,
    0x380c, 0x09, // 0x03
    0x380d, 0xcc, // 0x5C
    0x380e, 0x06,
    0x380f, 0x3d,
    0x3810, 0x00,
    0x3811, 0x04,
    0x3812, 0x00,
    0x3813, 0x02,
    0x3814, 0x03,
    0x3815, 0x01,
    0x3819, 0x01,
#if SENSOR_ROTATE_180
    0x3820, 0x16, // Tom: 0x00: No Flip, 0x06: Row & Column Flip
    0x3821, 0x01, // Tom: 0x06: No Flip, 0x00: Row & Column Flip
#else
    0x3820, 0x10,
    0x3821, 0x07,
#endif
    0x3829, 0x00,
    0x382a, 0x03,
    0x382b, 0x01,
    0x382d, 0x7f,
    0x3830, 0x08,
    0x3836, 0x02,
    0x3837, 0x00,
    0x3841, 0x02,
    0x3846, 0x08,
    0x3847, 0x07,
    0x3d85, 0x36,
    0x3d8c, 0x71,
    0x3d8d, 0xcb,
    0x3f0a, 0x00,
    0x4000, 0x71,
    0x4001, 0x50,
    0x4002, 0x04,
    0x4003, 0x14,
    0x400e, 0x00,
    0x4011, 0x00,
    0x401a, 0x00,
    0x401b, 0x00,
    0x401c, 0x00,
    0x401d, 0x00,
    0x401f, 0x00,
    0x4020, 0x00,
    0x4021, 0x10,
    0x4022, 0x03,
    0x4023, 0x9b,
    0x4024, 0x04,
    0x4025, 0xc8,
    0x4026, 0x04,
    0x4027, 0xd8,
    0x4028, 0x00,
    0x4029, 0x02,
    0x402a, 0x06,
    0x402b, 0x04,
    0x402c, 0x02,
    0x402d, 0x02,
    0x402e, 0x0e,
    0x402f, 0x04,
    0x4302, 0xff,
    0x4303, 0xff,
    0x4304, 0x00,
    0x4305, 0x00,
    0x4306, 0x00,
    0x4308, 0x02,
    0x4500, 0x6c,
    0x4501, 0xc4,
    0x4502, 0x44,
    0x4503, 0x01,
    0x4601, 0x4F,
    0x4800, 0x04,
    0x4813, 0x08,
    0x481f, 0x40,
    0x4829, 0x78,
    0x4837, 0x2c, // 0x20 // 0x10
    0x4b00, 0x2a,
    0x4b0d, 0x00,
    0x4d00, 0x04,
    0x4d01, 0x42,
    0x4d02, 0xd1,
    0x4d03, 0x93,
    0x4d04, 0xf5,
    0x4d05, 0xc1,
    0x5000, 0xf3,
    0x5001, 0x11,
    0x5004, 0x00,
    0x500a, 0x00,
    0x500b, 0x00,
    0x5032, 0x00,
    
#if (TEST_PATTERN_EN)
    0x5040, 0x80, // PRE_CONTROL00, 0x00, RW
                  // Bit[7]:   Test pattern enable
                  //           0: disable
                  //           1: enable
                  // Bit[6]:   Rolling bar enable
                  //           0: disable
                  //           1: enable
                  // Bit[5]:   Tansparent enable
                  //           0: disable
                  //           1: enable
                  // Bit[4]:   Square enable
                  //           0: Color square
                  //           1: Black-white square
                  // Bit[3:2]: Color style
                  //           00: Standard color bar
                  //           01: Top-bottom darker color bar
                  //           10: Right-left darker color bar
                  //           11: Bottom-top darker color bar
                  // Bit[1:0]: Test pattern mode
                  //           00: Color bar
                  //           01: Random data
                  //           10: Square
                  //           01: Black image
    0x5041, 0x00, // PRE_CONTROL01, 0x41, RW
                  // Bit[6]:   Window cut enable
                  //           0: disable
                  //           1: enable
                  // Bit[4]:   Same seed enable
                  //           When set, the seed used to generate the
                  //           random data are same which is set in
                  //           seed register
                  // Bit[3:0]: Seed
                  //           Seed used in generating random data
#else
    0x5040, 0x00,
#endif
    0x5050, 0x3c,
    0x5500, 0x00,
    0x5501, 0x10,
    0x5502, 0x01,
    0x5503, 0x0f,
    0x8000, 0x00,
    0x8001, 0x00,
    0x8002, 0x00,
    0x8003, 0x00,
    0x8004, 0x00,
    0x8005, 0x00,
    0x8006, 0x00,
    0x8007, 0x00,
    0x8008, 0x00,
    0x3638, 0x00,
    0x0100, 0x01
#endif
};

static ISP_UINT16 SNR_OV4689_Reg_1280x720_60P[] = 
{
#if (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
/*
 * @@ RES_1288x724_2x_Bin_60fps_360Mbps
 *
 * 100 99 1288 724
 * 102 3601 1770
 */

/*
 * ----------------------------------------------
 *  MCLK: 24Mhz
 *  resolution: 1288x724
 *  Mipi: 4 lane
 *  Mipi data rate: 360Mbps/Lane
 *  SystemCLK: 120Mhz
 *  FPS: 60 (= SystemCLK / (HTS * VTS))
 *  HTS: 2508 (R380c:R380d)
 *  VTS: 797 (R380e:R380f)
 *  Tline: 20.9us
 *  Max exp line: 779 (VTS-8)
 * ---------------------------------------------
 */

    0x0103, 0x01,
    0x3638, 0x00,
    0x0300, 0x00,
    0x0302, 0x1e, // 0x2a
    0x0303, 0x01, // 0x00
    0x0304, 0x03,
    0x030b, 0x00,
    0x030d, 0x1e,
    0x030e, 0x04,
    0x030f, 0x01,
    0x0312, 0x01,
    0x031e, 0x00,
    0x3000, 0x20,
    0x3002, 0x00,
    0x3018, 0x72, // 0x32/0x72 // 2lane/4lane
    0x3019, 0x00, // 0x0c/0x00 // 2lane/4lane
    0x3020, 0x93,
    0x3021, 0x03,
    0x3022, 0x01,
    0x3031, 0x0a,
    0x303f, 0x0c,
    0x3305, 0xf1,
    0x3307, 0x04,
    0x3309, 0x29,
    0x3500, 0x00,
    0x3501, 0x31,
    0x3502, 0x00,
    0x3503, 0x04,
    0x3504, 0x00,
    0x3505, 0x00,
    0x3506, 0x00,
    0x3507, 0x00,
    0x3508, 0x07, // 0x8X
    0x3509, 0x78, 
    0x350a, 0x00,
    0x350b, 0x00,
    0x350c, 0x00,
    0x350d, 0x00,
    0x350e, 0x00,
    0x350f, 0x80,
    0x3510, 0x00,
    0x3511, 0x00,
    0x3512, 0x00,
    0x3513, 0x00,
    0x3514, 0x00,
    0x3515, 0x80,
    0x3516, 0x00,
    0x3517, 0x00,
    0x3518, 0x00,
    0x3519, 0x00,
    0x351a, 0x00,
    0x351b, 0x80,
    0x351c, 0x00,
    0x351d, 0x00,
    0x351e, 0x00,
    0x351f, 0x00,
    0x3520, 0x00,
    0x3521, 0x80,
    0x3522, 0x08,
    0x3524, 0x08,
    0x3526, 0x08,
    0x3528, 0x08,
    0x352a, 0x08,
    0x3602, 0x00,
    0x3603, 0x40,
    0x3604, 0x02,
    0x3605, 0x00,
    0x3606, 0x00,
    0x3607, 0x00,
    0x3609, 0x12,
    0x360a, 0x40,
    0x360c, 0x08,
	//0x360f, 0xe5,
    //0x360f, 0xdb,
    0x360f, 0xe0,
    0x3608, 0x8f,
    0x3611, 0x00,
    0x3613, 0xf7,
    0x3616, 0x58,
    0x3619, 0x99,
    0x361b, 0x60,
    0x361c, 0x7a,
    0x361e, 0x79,
    0x361f, 0x02,
    0x3632, 0x05,
    0x3633, 0x10,
    0x3634, 0x10,
    0x3635, 0x10,
	//0x3636, 0x15,
    0x3636, 0x10,
    0x3646, 0x86,
    0x364a, 0x0b,
    0x3700, 0x17,
    0x3701, 0x22,
    0x3703, 0x10,
    0x370a, 0x37,
    0x3705, 0x00,
    0x3706, 0x63,
    0x3709, 0x3c,
    0x370b, 0x01,
    0x370c, 0x30,
    0x3710, 0x24,
    0x3711, 0x0c,
    0x3716, 0x00,
    0x3720, 0x28,
    0x3729, 0x7b,
    0x372a, 0x84,
    0x372b, 0xbd,
    0x372c, 0xbc,
    0x372e, 0x52,
    0x373c, 0x0e,
    0x373e, 0x33,
    0x3743, 0x10,
    0x3744, 0x88,
    0x3745, 0xc0,
    0x374a, 0x43,
    0x374c, 0x00,
    0x374e, 0x23,
    0x3751, 0x7b,
    0x3752, 0x84,
    0x3753, 0xbd,
    0x3754, 0xbc,
    0x3756, 0x52,
    0x375c, 0x00,
    0x3760, 0x00,
    0x3761, 0x00,
    0x3762, 0x00,
    0x3763, 0x00,
    0x3764, 0x00,
    0x3767, 0x04,
    0x3768, 0x04,
    0x3769, 0x08,
    0x376a, 0x08,
    0x376b, 0x40,
    0x376c, 0x00,
    0x376d, 0x00,
    0x376e, 0x00,
    0x3773, 0x00,
    0x3774, 0x51,
    0x3776, 0xbd,
    0x3777, 0xbd,
    0x3781, 0x18,
    0x3783, 0x25,
    0x3798, 0x1b,
    0x3800, 0x00,
    0x3801, 0x40,
    0x3802, 0x00,
    0x3803, 0x28,
    0x3804, 0x0a,
    0x3805, 0x5f,
    0x3806, 0x05,
    0x3807, 0xD7,
    0x3808, 0x05,
    0x3809, 0x08,
    0x380a, 0x02,
    0x380b, 0xD4,
    0x380c, 0x09, // 0x03
    0x380d, 0xcc, // 0x5C
    0x380e, 0x03,
    0x380f, 0x1d,
    0x3810, 0x00,
    0x3811, 0x04,
    0x3812, 0x00,
    0x3813, 0x02,
    0x3814, 0x03,
    0x3815, 0x01,
    0x3819, 0x01,
#if SENSOR_ROTATE_180
    0x3820, 0x16, // Tom: 0x00: No Flip, 0x06: Row & Column Flip
    0x3821, 0x01, // Tom: 0x06: No Flip, 0x00: Row & Column Flip
#else
    0x3820, 0x10,
    0x3821, 0x07,
#endif
    0x3829, 0x00,
    0x382a, 0x03,
    0x382b, 0x01,
    0x382d, 0x7f,
    0x3830, 0x08,
    0x3836, 0x02,
    0x3837, 0x00,
    0x3841, 0x02,
    0x3846, 0x08,
    0x3847, 0x07,
    0x3d85, 0x36,
    0x3d8c, 0x71,
    0x3d8d, 0xcb,
    0x3f0a, 0x00,
    0x4000, 0x71,
    0x4001, 0x50,
    0x4002, 0x04,
    0x4003, 0x14,
    0x400e, 0x00,
    0x4011, 0x00,
    0x401a, 0x00,
    0x401b, 0x00,
    0x401c, 0x00,
    0x401d, 0x00,
    0x401f, 0x00,
    0x4020, 0x00,
    0x4021, 0x10,
    0x4022, 0x03,
    0x4023, 0x9b,
    0x4024, 0x04,
    0x4025, 0xc8,
    0x4026, 0x04,
    0x4027, 0xd8,
    0x4028, 0x00,
    0x4029, 0x02,
    0x402a, 0x06,
    0x402b, 0x04,
    0x402c, 0x02,
    0x402d, 0x02,
    0x402e, 0x0e,
    0x402f, 0x04,
    0x4302, 0xff,
    0x4303, 0xff,
    0x4304, 0x00,
    0x4305, 0x00,
    0x4306, 0x00,
    0x4308, 0x02,
    0x4500, 0x6c,
    0x4501, 0xc4,
    0x4502, 0x44,
    0x4503, 0x01,
    0x4601, 0x4F,
    0x4800, 0x04,
    0x4813, 0x08,
    0x481f, 0x40,
    0x4829, 0x78,
    0x4837, 0x2c, // 0x20 // 0x10
    0x4b00, 0x2a,
    0x4b0d, 0x00,
    0x4d00, 0x04,
    0x4d01, 0x42,
    0x4d02, 0xd1,
    0x4d03, 0x93,
    0x4d04, 0xf5,
    0x4d05, 0xc1,
    0x5000, 0xf3,
    0x5001, 0x11,
    0x5004, 0x00,
    0x500a, 0x00,
    0x500b, 0x00,
    0x5032, 0x00,
    
#if (TEST_PATTERN_EN)
    0x5040, 0x80, // PRE_CONTROL00, 0x00, RW
                  // Bit[7]:   Test pattern enable
                  //           0: disable
                  //           1: enable
                  // Bit[6]:   Rolling bar enable
                  //           0: disable
                  //           1: enable
                  // Bit[5]:   Tansparent enable
                  //           0: disable
                  //           1: enable
                  // Bit[4]:   Square enable
                  //           0: Color square
                  //           1: Black-white square
                  // Bit[3:2]: Color style
                  //           00: Standard color bar
                  //           01: Top-bottom darker color bar
                  //           10: Right-left darker color bar
                  //           11: Bottom-top darker color bar
                  // Bit[1:0]: Test pattern mode
                  //           00: Color bar
                  //           01: Random data
                  //           10: Square
                  //           01: Black image
    0x5041, 0x00, // PRE_CONTROL01, 0x41, RW
                  // Bit[6]:   Window cut enable
                  //           0: disable
                  //           1: enable
                  // Bit[4]:   Same seed enable
                  //           When set, the seed used to generate the
                  //           random data are same which is set in
                  //           seed register
                  // Bit[3:0]: Seed
                  //           Seed used in generating random data
#else
    0x5040, 0x00,
#endif
    0x5050, 0x3c,
    0x5500, 0x00,
    0x5501, 0x10,
    0x5502, 0x01,
    0x5503, 0x0f,
    0x8000, 0x00,
    0x8001, 0x00,
    0x8002, 0x00,
    0x8003, 0x00,
    0x8004, 0x00,
    0x8005, 0x00,
    0x8006, 0x00,
    0x8007, 0x00,
    0x8008, 0x00,
    0x3638, 0x00,
    0x0100, 0x01
#endif
};

static ISP_UINT16 SNR_OV4689_Reg_1280x720_100P[] = 
{
#if (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#endif
};

ISP_UINT16 SNR_OV4689_Reg_1280x720_120P[] = 
{
#if (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)

//----------------------------------------------
// MCLK: 24Mhz
// resolution: 1348x760 (10bit) 
// Mipi : 4 lane 
// Mipi data rate: 360Mbps/Lane
// SystemCLK   :120Mhz
// FPS	     :120 ( = SystemCLK / (HTS*VTS) ) 
//  #if (ADD_VTS)
// HTS		:1218 (R380c:R380d)
// VTS		:821 (R380e:R380f)
// Tline 	:10.15us
// Max exp line	:817( VTS-4	)
//  #else
// HTS		:1254 (R380c:R380d)
// VTS		:797(R380e:R380f)
// Tline 	:10.45us
// Max exp line	:779( VTS-8	)
//  #endif
//---------------------------------------------

    0x0103,	0x01,
    0x3638,	0x00,
    0x0300,	0x00,
    0x0302,	0x1e,
    0x0303,	0x01,
    0x0304,	0x03,
    0x030b,	0x00,
    0x030d,	0x1e,
    0x030e,	0x04,
    0x030f,	0x01,
#ifdef SPECIAL_VERSION_15FPS
    #if SPECIAL_VERSION_15FPS
    0x0311, 0x01,
    #endif
#endif
    0x0312,	0x01,
    0x031e,	0x00,
    0x3000,	0x20,
    0x3002,	0x00,
    0x3018,	0x72,
    0x3019,	0x00,
    0x3020,	0x93,
    0x3021,	0x03,
    0x3022,	0x01,
    0x3031,	0x0a,
    0x303f,	0x0c,
    0x3305,	0xf1,
    0x3307,	0x04,
    0x3309,	0x29,
    0x3500,	0x00,
    0x3501,	0x31,
    0x3502,	0x00,
    0x3503,	0x64,//0x04,
    0x3504,	0x00,
    0x3505,	0x00,
    0x3506,	0x00,
    0x3507,	0x00,
    0x3508,	0x07,
    0x3509,	0x78,
    0x350a,	0x00,
    0x350b,	0x00,
    0x350c,	0x00,
    0x350d,	0x00,
    0x350e,	0x00,
    0x350f,	0x80,
    0x3510,	0x00,
    0x3511,	0x00,
    0x3512,	0x00,
    0x3513,	0x00,
    0x3514,	0x00,
    0x3515,	0x80,
    0x3516,	0x00,
    0x3517,	0x00,
    0x3518,	0x00,
    0x3519,	0x00,
    0x351a,	0x00,
    0x351b,	0x80,
    0x351c,	0x00,
    0x351d,	0x00,
    0x351e,	0x00,
    0x351f,	0x00,
    0x3520,	0x00,
    0x3521,	0x80,
    0x3522,	0x08,
    0x3524,	0x08,
    0x3526,	0x08,
    0x3528,	0x08,
    0x352a,	0x08,
    0x3602,	0x00,
    0x3603,	0x40,
    0x3604,	0x02,
    0x3605,	0x00,
    0x3606,	0x00,
    0x3607,	0x00,
    0x3609,	0x12,
    0x360a,	0x40,
    0x360c,	0x08,
    //0x360f,	0xe5,
    0x360f, 0xe0,
    0x3608,	0x8f,
    0x3611,	0x00,
    0x3613,	0xf7,
    0x3616,	0x58,
    0x3619,	0x99,
    0x361b,	0x60,
    0x361c,	0x7a,
    0x361e,	0x79,
    0x361f,	0x02,
    0x3632,	0x05,
    0x3633,	0x10,
    0x3634,	0x10,
    0x3635,	0x10,
    //0x3636,	0x15,
    0x3636, 0x10,
    0x3646,	0x86,
    0x364a,	0x0b,
    0x3700,	0x17,
    0x3701,	0x22,
    0x3703,	0x10,
    0x370a,	0x37,
    0x3705,	0x00,
    0x3706,	0x63,
    0x3709,	0x3c,
    0x370b,	0x01,
    0x370c,	0x30,
    0x3710,	0x24,
    0x3711,	0x0c,
    0x3716,	0x00,
    0x3720,	0x28,
    0x3729,	0x7b,
    0x372a,	0x84,
    0x372b,	0xbd,
    0x372c,	0xbc,
    0x372e,	0x52,
    0x373c,	0x0e,
    0x373e,	0x33,
    0x3743,	0x10,
    0x3744,	0x88,
    0x3745,	0xc0,
    0x374a,	0x43,
    0x374c,	0x00,
    0x374e,	0x23,
    0x3751,	0x7b,
    0x3752,	0x84,
    0x3753,	0xbd,
    0x3754,	0xbc,
    0x3756,	0x52,
    0x375c,	0x00,
    0x3760,	0x00,
    0x3761,	0x00,
    0x3762,	0x00,
    0x3763,	0x00,
    0x3764,	0x00,
    0x3767,	0x04,
    0x3768,	0x04,
    0x3769,	0x08,
    0x376a,	0x08,
    0x376b,	0x40,
    0x376c,	0x00,
    0x376d,	0x00,
    0x376e,	0x00,
    0x3773,	0x00,
    0x3774,	0x51,
    0x3776,	0xbd,
    0x3777,	0xbd,
    0x3781,	0x18,
    0x3783,	0x25,
    0x3798,	0x1b,
    0x3800,	0x00,
    0x3801,	0x04,
    0x3802,	0x00,
    0x3803,	0x04,
    0x3804,	0x0a,
    0x3805,	0x9B,
    0x3806,	0x05,
    0x3807,	0xFB,
    0x3808,	0x05,
    0x3809,	0x44,
    0x380a,	0x02,
    0x380b,	0xF8,
#if (ADD_VTS)
    0x380c,	0x04, //1218
    0x380d,	0xc2,
    0x380e,	0x03, //821
    0x380f,	0x35,
#else    
    0x380c,	0x04, //1254
    0x380d,	0xe6,
    0x380e,	0x03, //797 
    0x380f,	0x1d,
#endif    
    0x3810,	0x00,
    0x3811,	0x04,
    0x3812,	0x00,
    0x3813,	0x02,
    0x3814,	0x03,
    0x3815,	0x01,
    0x3819,	0x01,
#if SENSOR_ROTATE_180
    0x3820, 0x16, // Tom: 0x00: No Flip, 0x06: Row & Column Flip
    0x3821, 0x01, // Tom: 0x06: No Flip, 0x00: Row & Column Flip
#else
    0x3820,	0x10,
    0x3821,	0x07,
#endif
    0x3829,	0x00,
    0x382a,	0x03,
    0x382b,	0x01,
    0x382d,	0x7f,
    0x3830,	0x08,
    0x3836,	0x02,
    0x3837,	0x00,
    0x3841,	0x02,
    0x3846,	0x08,
    0x3847,	0x07,
    0x3d85,	0x36,
    0x3d8c,	0x71,
    0x3d8d,	0xcb,
    0x3f0a,	0x00,
    0x4000,	0xF1,
    0x4001,	0x50,
    0x4002,	0x04,
    0x4003,	0x14,
    0x400e,	0x00,
    0x4011,	0x00,
    0x401a,	0x00,
    0x401b,	0x00,
    0x401c,	0x00,
    0x401d,	0x00,
    0x401f,	0x00,
    0x4020,	0x00,
    0x4021,	0x10,
    0x4022,	0x03,
    0x4023,	0xD7,
    0x4024,	0x05,
    0x4025,	0x04,
    0x4026,	0x05,
    0x4027,	0x14,
    0x4028,	0x00,
    0x4029,	0x02,
    0x402a,	0x06,
    0x402b,	0x04,
    0x402c,	0x02,
    0x402d,	0x02,
    0x402e,	0x0e,
    0x402f,	0x04,
    0x4302,	0xff,
    0x4303,	0xff,
    0x4304,	0x00,
    0x4305,	0x00,
    0x4306,	0x00,
    0x4308,	0x02,
    0x4500,	0x6c,
    0x4501,	0xc4,
    0x4502,	0x44,
    0x4503,	0x01,
    0x4601,	0x53,
    0x4800,	0x04,
    0x4813,	0x08,
    0x481f,	0x40,
    0x4829,	0x78,
    0x4837,	0x2c,
    0x4b00,	0x2a,
    0x4b0d,	0x00,
    0x4d00,	0x04,
    0x4d01,	0x42,
    0x4d02,	0xd1,
    0x4d03,	0x93,
    0x4d04,	0xf5,
    0x4d05,	0xc1,
    0x5000,	0xf3,
    0x5001,	0x11,
    0x5004,	0x00,
    0x500a,	0x00,
    0x500b,	0x00,
    0x5032,	0x00,
    0x5040,	0x00,
    0x5050,	0x3c,
    0x5500,	0x00,
    0x5501,	0x10,
    0x5502,	0x01,
    0x5503,	0x0f,
    0x8000,	0x00,
    0x8001,	0x00,
    0x8002,	0x00,
    0x8003,	0x00,
    0x8004,	0x00,
    0x8005,	0x00,
    0x8006,	0x00,
    0x8007,	0x00,
    0x8008,	0x00,
    0x3638,	0x00,
    0x0100,	0x01,
#endif
};

static ISP_UINT16 SNR_OV4689_Reg_640x480_30P[] = 
{
#if (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
/*
 * @@ RES_644x482_2x_Bin_30fps_360Mbps
 *
 * 100 99 644 482
 * 102 3601 bb8
 */

/*
 * ----------------------------------------------
 *  MCLK: 24Mhz
 *  resolution: 644x482
 *  Mipi: 4 lane
 *  Mipi data rate: 360Mbps/Lane
 *  SystemCLK: 120Mhz
 *  FPS: 29.96 (= SystemCLK / (HTS * VTS))
 *  HTS: 2508 (R380c:R380d)
 *  VTS: 1597 (R380e:R380f)
 *  Tline: 20.9us
 *  Max exp line: 1589 (VTS-8)
 * ---------------------------------------------
 */

    0x0103, 0x01,
    0x3638, 0x00,
    0x0300, 0x00,
    0x0302, 0x1e, // 0x2a
    0x0303, 0x01, // 0x00
    0x0304, 0x03,
    0x030b, 0x00,
    0x030d, 0x1e,
    0x030e, 0x04,
    0x030f, 0x01,
    0x0312, 0x01,
    0x031e, 0x00,
    0x3000, 0x20,
    0x3002, 0x00,
    0x3018, 0x72, // 0x32/0x72 // 2lane/4lane
    0x3019, 0x00, // 0x0c/0x00 // 2lane/4lane
    0x3020, 0x93,
    0x3021, 0x03,
    0x3022, 0x01,
    0x3031, 0x0a,
    0x303f, 0x0c,
    0x3305, 0xf1,
    0x3307, 0x04,
    0x3309, 0x29,
    0x3500, 0x00,
    0x3501, 0x63,
    0x3502, 0x00,
    0x3503, 0x04,
    0x3504, 0x00,
    0x3505, 0x00,
    0x3506, 0x00,
    0x3507, 0x00,
    0x3508, 0x07, // 0x8X
    0x3509, 0x78, 
    0x350a, 0x00,
    0x350b, 0x00,
    0x350c, 0x00,
    0x350d, 0x00,
    0x350e, 0x00,
    0x350f, 0x80,
    0x3510, 0x00,
    0x3511, 0x00,
    0x3512, 0x00,
    0x3513, 0x00,
    0x3514, 0x00,
    0x3515, 0x80,
    0x3516, 0x00,
    0x3517, 0x00,
    0x3518, 0x00,
    0x3519, 0x00,
    0x351a, 0x00,
    0x351b, 0x80,
    0x351c, 0x00,
    0x351d, 0x00,
    0x351e, 0x00,
    0x351f, 0x00,
    0x3520, 0x00,
    0x3521, 0x80,
    0x3522, 0x08,
    0x3524, 0x08,
    0x3526, 0x08,
    0x3528, 0x08,
    0x352a, 0x08,
    0x3602, 0x00,
    0x3603, 0x40,
    0x3604, 0x02,
    0x3605, 0x00,
    0x3606, 0x00,
    0x3607, 0x00,
    0x3609, 0x12,
    0x360a, 0x40,
    0x360c, 0x08,
	//0x360f, 0xe5,
    //0x360f, 0xdb,
    0x360f, 0xe0,
    0x3608, 0x8f,
    0x3611, 0x00,
    0x3613, 0xf7,
    0x3616, 0x58,
    0x3619, 0x99,
    0x361b, 0x60,
    0x361c, 0x7a,
    0x361e, 0x79,
    0x361f, 0x02,
    0x3632, 0x05,
    0x3633, 0x10,
    0x3634, 0x10,
    0x3635, 0x10,
	//0x3636, 0x15,
    0x3636, 0x10,
    0x3646, 0x86,
    0x364a, 0x0b,
    0x3700, 0x17,
    0x3701, 0x22,
    0x3703, 0x10,
    0x370a, 0x37,
    0x3705, 0x00,
    0x3706, 0x63,
    0x3709, 0x3c,
    0x370b, 0x01,
    0x370c, 0x30,
    0x3710, 0x24,
    0x3711, 0x0c,
    0x3716, 0x00,
    0x3720, 0x28,
    0x3729, 0x7b,
    0x372a, 0x84,
    0x372b, 0xbd,
    0x372c, 0xbc,
    0x372e, 0x52,
    0x373c, 0x0e,
    0x373e, 0x33,
    0x3743, 0x10,
    0x3744, 0x88,
    0x3745, 0xc0,
    0x374a, 0x43,
    0x374c, 0x00,
    0x374e, 0x23,
    0x3751, 0x7b,
    0x3752, 0x84,
    0x3753, 0xbd,
    0x3754, 0xbc,
    0x3756, 0x52,
    0x375c, 0x00,
    0x3760, 0x00,
    0x3761, 0x00,
    0x3762, 0x00,
    0x3763, 0x00,
    0x3764, 0x00,
    0x3767, 0x04,
    0x3768, 0x04,
    0x3769, 0x08,
    0x376a, 0x08,
    0x376b, 0x40,
    0x376c, 0x00,
    0x376d, 0x00,
    0x376e, 0x00,
    0x3773, 0x00,
    0x3774, 0x51,
    0x3776, 0xbd,
    0x3777, 0xbd,
    0x3781, 0x18,
    0x3783, 0x25,
    0x3798, 0x1b,
    0x3800, 0x02, 	//Xstart
    0x3801, 0xc4,
    0x3802, 0x01,	//Ystart
    0x3803, 0x1a,
    0x3804, 0x07, 	//XEnd
    0x3805, 0xdb,
    0x3806, 0x04, 	//YEnd
    0x3807, 0xe5,
    0x3808, 0x02,  	//XSize
    0x3809, 0x84,
    0x380a, 0x01,  	//YSize
    0x380b, 0xe2,
    0x380c, 0x09, // 0x03
    0x380d, 0xcc, // 0x5C
    0x380e, 0x06,
    0x380f, 0x3d,
    0x3810, 0x00,
    0x3811, 0x04,
    0x3812, 0x00,
    0x3813, 0x02,
    0x3814, 0x03,
    0x3815, 0x01,
    0x3819, 0x01,
#if SENSOR_ROTATE_180
    0x3820, 0x16, // Tom: 0x00: No Flip, 0x06: Row & Column Flip
    0x3821, 0x01, // Tom: 0x06: No Flip, 0x00: Row & Column Flip
#else
    0x3820, 0x10,
    0x3821, 0x07,
#endif
    0x3829, 0x00,
    0x382a, 0x03,
    0x382b, 0x01,
    0x382d, 0x7f,
    0x3830, 0x08,
    0x3836, 0x02,
    0x3837, 0x00,
    0x3841, 0x02,
    0x3846, 0x08,
    0x3847, 0x07,
    0x3d85, 0x36,
    0x3d8c, 0x71,
    0x3d8d, 0xcb,
    0x3f0a, 0x00,
    0x4000, 0x71,
    0x4001, 0x50,
    0x4002, 0x04,
    0x4003, 0x14,
    0x400e, 0x00,
    0x4011, 0x00,
    0x401a, 0x00,
    0x401b, 0x00,
    0x401c, 0x00,
    0x401d, 0x00,
    0x401f, 0x00,
    0x4020, 0x00,
    0x4021, 0x10,
    0x4022, 0x01, // 0x03
    0x4023, 0x17, // 0x93
    0x4024, 0x02, // 0x04
    0x4025, 0x44, // 0xC0
    0x4026, 0x02, // 0x04
    0x4027, 0x54, // 0xD0
    0x4028, 0x00,
    0x4029, 0x02,
    0x402a, 0x06,
    0x402b, 0x04,
    0x402c, 0x02,
    0x402d, 0x02,
    0x402e, 0x0e,
    0x402f, 0x04,
    0x4302, 0xff,
    0x4303, 0xff,
    0x4304, 0x00,
    0x4305, 0x00,
    0x4306, 0x00,
    0x4308, 0x02,
    0x4500, 0x6c,
    0x4501, 0xc4,
    0x4502, 0x44,
    0x4503, 0x01,
    0x4601, 0x27, // 0x4F
    0x4800, 0x04,
    0x4813, 0x08,
    0x481f, 0x40,
    0x4829, 0x78,
    0x4837, 0x2c, // 0x20 // 0x10
    0x4b00, 0x2a,
    0x4b0d, 0x00,
    0x4d00, 0x04,
    0x4d01, 0x42,
    0x4d02, 0xd1,
    0x4d03, 0x93,
    0x4d04, 0xf5,
    0x4d05, 0xc1,
    0x5000, 0xf3,
    0x5001, 0x11,
    0x5004, 0x00,
    0x500a, 0x00,
    0x500b, 0x00,
    0x5032, 0x00,
    
#if (TEST_PATTERN_EN)
    0x5040, 0x80, // PRE_CONTROL00, 0x00, RW
                  // Bit[7]:   Test pattern enable
                  //           0: disable
                  //           1: enable
                  // Bit[6]:   Rolling bar enable
                  //           0: disable
                  //           1: enable
                  // Bit[5]:   Tansparent enable
                  //           0: disable
                  //           1: enable
                  // Bit[4]:   Square enable
                  //           0: Color square
                  //           1: Black-white square
                  // Bit[3:2]: Color style
                  //           00: Standard color bar
                  //           01: Top-bottom darker color bar
                  //           10: Right-left darker color bar
                  //           11: Bottom-top darker color bar
                  // Bit[1:0]: Test pattern mode
                  //           00: Color bar
                  //           01: Random data
                  //           10: Square
                  //           01: Black image
    0x5041, 0x00, // PRE_CONTROL01, 0x41, RW
                  // Bit[6]:   Window cut enable
                  //           0: disable
                  //           1: enable
                  // Bit[4]:   Same seed enable
                  //           When set, the seed used to generate the
                  //           random data are same which is set in
                  //           seed register
                  // Bit[3:0]: Seed
                  //           Seed used in generating random data
#else
    0x5040, 0x00,
#endif
    0x5050, 0x3c,
    0x5500, 0x00,
    0x5501, 0x10,
    0x5502, 0x01,
    0x5503, 0x0f,
    0x8000, 0x00,
    0x8001, 0x00,
    0x8002, 0x00,
    0x8003, 0x00,
    0x8004, 0x00,
    0x8005, 0x00,
    0x8006, 0x00,
    0x8007, 0x00,
    0x8008, 0x00,
    0x3638, 0x00,
    0x0100, 0x01
#endif
};

static ISP_UINT16 SNR_OV4689_Reg_1520x1520_30P[] = 
{
#if (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
    // @@Initial Setting 2688x1520_30fps_840Mbps_2lane
    0x0103, 0x01,
    0x3638, 0x00,
    0x0300, 0x00,
    0x0302, 0x20,//0x23
    0x0303, 0x00,
    0x0304, 0x03,
    0x030b, 0x00,
    0x030d, 0x1e,
    0x030e, 0x04,
    0x030f, 0x01,
    0x0312, 0x01,
    0x031e, 0x00,
    0x3000, 0x20,
    0x3002, 0x80,// 0x00, //frame sync master mode lucas
    0x3018, 0x32,
    0x3020, 0x93,
    0x3021, 0x03,
    0x3022, 0x01,
    0x3031, 0x08,//0x0a, 10bit->8bit
    0x303f, 0x0c,
    0x3305, 0xf1,
    0x3307, 0x04,
    0x3309, 0x29,
    0x3500, 0x00,
    0x3501, 0x60,
    0x3502, 0x00,
    0x3503, 0x04,
    0x3504, 0x00,
    0x3505, 0x00,
    0x3506, 0x00,
    0x3507, 0x00,
    0x3508, 0x00,
    0x3509, 0x80,
    0x350a, 0x00,
    0x350b, 0x00,
    0x350c, 0x00,
    0x350d, 0x00,
    0x350e, 0x00,
    0x350f, 0x80,
    0x3510, 0x00,
    0x3511, 0x00,
    0x3512, 0x00,
    0x3513, 0x00,
    0x3514, 0x00,
    0x3515, 0x80,
    0x3516, 0x00,
    0x3517, 0x00,
    0x3518, 0x00,
    0x3519, 0x00,
    0x351a, 0x00,
    0x351b, 0x80,
    0x351c, 0x00,
    0x351d, 0x00,
    0x351e, 0x00,
    0x351f, 0x00,
    0x3520, 0x00,
    0x3521, 0x80,
    0x3522, 0x08,
    0x3524, 0x08,
    0x3526, 0x08,
    0x3528, 0x08,
    0x352a, 0x08,
    0x3602, 0x00,
    0x3603, 0x40,
    0x3604, 0x02,
    0x3605, 0x00,
    0x3606, 0x00,
    0x3607, 0x00,
    0x3609, 0x12,
    0x360a, 0x40,
    0x360c, 0x08,
    0x360f, 0xe0,
    0x3608, 0x8f,
    0x3611, 0x00,
    0x3613, 0xf7,
    0x3616, 0x58,
    0x3619, 0x99,
    0x361b, 0x60,
    0x361c, 0x7a,
    0x361e, 0x79,
    0x361f, 0x02,
    0x3632, 0x00,
    0x3633, 0x10,
    0x3634, 0x10,
    0x3635, 0x10,
    0x3636, 0x10,
    0x3646, 0x86,
    0x364a, 0x0b,
    0x3700, 0x17,
    0x3701, 0x22,
    0x3703, 0x10,
    0x370a, 0x37,
    0x3705, 0x00,
    0x3706, 0x63,
    0x3709, 0x3c,
    0x370b, 0x01,
    0x370c, 0x30,
    0x3710, 0x24,
    0x3711, 0x0c,
    0x3716, 0x00,
    0x3720, 0x28,
    0x3729, 0x7b,
    0x372a, 0x84,
    0x372b, 0xbd,
    0x372c, 0xbc,
    0x372e, 0x52,
    0x373c, 0x0e,
    0x373e, 0x33,
    0x3743, 0x10,
    0x3744, 0x88,
    0x3745, 0xc0,
    0x374a, 0x43,
    0x374c, 0x00,
    0x374e, 0x23,
    0x3751, 0x7b,
    0x3752, 0x84,
    0x3753, 0xbd,
    0x3754, 0xbc,
    0x3756, 0x52,
    0x375c, 0x00,
    0x3760, 0x00,
    0x3761, 0x00,
    0x3762, 0x00,
    0x3763, 0x00,
    0x3764, 0x00,
    0x3767, 0x04,
    0x3768, 0x04,
    0x3769, 0x08,
    0x376a, 0x08,
    0x376b, 0x20,
    0x376c, 0x00,
    0x376d, 0x00,
    0x376e, 0x00,
    0x3773, 0x00,
    0x3774, 0x51,
    0x3776, 0xbd,
    0x3777, 0xbd,
    0x3781, 0x18,
    0x3783, 0x25,
    0x3798, 0x1b,

    0x3800, 0x02,//Xs
    0x3801, 0x50,
    0x3802, 0x00,//Ys
    0x3803, 0x04,//0x00,
    0x3804, 0x08,//Xe
    0x3805, 0x4F,//0x35,
    0x3806, 0x05,//0x05,//Ye
    0x3807, 0xFB,//0xEF,//0xFD,
    0x3808, 0x05,//0x5F0 = 1520  0x600 = 1536  5Fc=1532
    0x3809, 0xF0,//0xEC,
    0x380A, 0x05,//0x5F0 = 1520 0x5EC = 1516
    0x380B, 0xF0,//0xEC,
    #if 0//(INSTA360_DEMO_EN) // 25FPS
    0x380C, 0x0C,
    0x380D, 0x18,
    #else
    0x380C, 0x0A,
    0x380D, 0x14,
    #endif
    0x380E, 0x06,
    0x380F, 0x14,
    0x3810, 0x00,
    0x3811, 0x08,
    0x3812, 0x00,
    0x3813, 0x04,
    0x3814, 0x01,
    0x3815, 0x01,
    0x3819, 0x01,
#if 0//SENSOR_ROTATE_180
    0x3820, 0x06, // Tom: 0x00: No Flip, 0x06: Row & Column Flip
    0x3821, 0x00, // Tom: 0x06: No Flip, 0x00: Row & Column Flip
#else
    0x3820, 0x00,
    0x3821, 0x06,
#endif
    //for frame sync //lucas test
    0x3823, 0x00,
    0x3824, 0x00,
    0x3825, 0x20,//0x00,
    0x3826, 0x00,
    0x3827, 0x04,//0x00,
    //end of frame sync setting
    0x3829, 0x00,
    0x382a, 0x01,
    0x382b, 0x01,
    0x382d, 0x7f,
    0x3830, 0x04,
    0x3836, 0x01,
    0x3837, 0x00,
    0x3841, 0x02,
    0x3846, 0x08,
    0x3847, 0x07,
    0x3d85, 0x36,
    0x3d8c, 0x71,
    0x3d8d, 0xcb,
    0x3f0a, 0x00,
    0x4000, 0x71,
    0x4001, 0x40,
    0x4002, 0x04,
    0x4003, 0x14,
    0x400e, 0x00,
    0x4011, 0x00,
    0x401a, 0x00,
    0x401b, 0x00,
    0x401c, 0x00,
    0x401d, 0x00,
    0x401f, 0x00,
    0x4020, 0x00,
    0x4021, 0x10,
    0x4022, 0x04,
    0x4023, 0x83,
    0x4024, 0x05,
    0x4025, 0xB0,
    0x4026, 0x05,
    0x4027, 0xC0,
    0x4028, 0x00,
    0x4029, 0x02,
    0x402a, 0x06,
    0x402b, 0x04,
    0x402c, 0x02,
    0x402d, 0x02,
    0x402e, 0x0e,
    0x402f, 0x04,
    0x4302, 0xff,
    0x4303, 0xff,
    0x4304, 0x00,
    0x4305, 0x00,
    0x4306, 0x00,
    0x4308, 0x02,
    0x4500, 0x6c,
    0x4501, 0xc4,
    0x4502, 0x40,
    0x4503, 0x01,
    0x4600, 0x00,
    #if 1
    0x4601, 0x5E,
    #else
    0x4601, 0xA7,
    #endif
    0x4800, 0x04,
    0x4813, 0x08,
    0x481f, 0x40,
    0x4829, 0x78,
    0x4837, 0x14,
    0x4b00, 0x2a,
    0x4b0d, 0x00,
    0x4d00, 0x04,
    0x4d01, 0x42,
    0x4d02, 0xd1,
    0x4d03, 0x93,
    0x4d04, 0xf5,
    0x4d05, 0xc1,
    0x5000, 0xf3,
    0x5001, 0x11,
    0x5004, 0x00,
    0x500a, 0x00,
    0x500b, 0x00,
    0x5032, 0x00,
    0x5040, 0x00,
    0x5050, 0x0c,
    0x5500, 0x00,
    0x5501, 0x10,
    0x5502, 0x01,
    0x5503, 0x0f,
    0x8000, 0x00,
    0x8001, 0x00,
    0x8002, 0x00,
    0x8003, 0x00,
    0x8004, 0x00,
    0x8005, 0x00,
    0x8006, 0x00,
    0x8007, 0x00,
    0x8008, 0x00,
    0x3638, 0x00,
    0x0100, 0x01,// streaming on    

#elif (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#endif
};

//*** Scale Up 4K@24fps (Index 15)
//Reference: Index 2
static ISP_UINT16 SNR_OV4689_Reg_2688x1512_24P[] = 
{
#if (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
    // TBD
    SENSOR_DELAY_REG, 100 // delay
#elif (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
/*
 * ----------------------------------------------
 *  MCLK: 24Mhz
 *  resolution: 2692x1524 (8bit)
 *  Mipi: 4 lane
 *  Mipi data rate: 324///360Mbps/Lane
 *  SystemCLK: 120Mhz
 *  FPS: 24 (= SystemCLK / (HTS * VTS))
 *  HTS: 3201 (R380c:R380d)
 *  VTS: 1562 (R380e:R380f)
 *  Tline: 21.33us
 *  Max exp line: 1558 (VTS-4)
 * ---------------------------------------------
 */
 
    0x0103, 0x01,
    0x3638, 0x00,
    0x0300, 0x00,
    0x0302, 0x1b,///0x1e, // 2a
    0x0303, 0x01, // 00
    0x0304, 0x03,
    0x030b, 0x00,
    0x030d, 0x1e,
    0x030e, 0x04,
    0x030f, 0x01,
#ifdef SPECIAL_VERSION_15FPS
    #if SPECIAL_VERSION_15FPS
    0x0311, 0x01,
    #endif
#endif
    0x0312, 0x01,
    0x031e, 0x00,
    0x3000, 0x20,
    0x3002, 0x00,
    0x3018, 0x72,
    0x3020, 0x93,
    0x3021, 0x03,
    0x3022, 0x01,
    0x3031, 0x08,///0x0a,
    0x303f, 0x0c,
    0x3305, 0xf1,
    0x3307, 0x04,
    0x3309, 0x29,
    0x3500, 0x00,
    0x3501, 0x61,
    0x3502, 0x00,
    0x3503, 0x64,//0x04,
    0x3504, 0x00,
    0x3505, 0x00,
    0x3506, 0x00,
    0x3507, 0x00,
    0x3508, 0x07, // 8X
    0x3509, 0x78, // 80
    0x350a, 0x00,
    0x350b, 0x00,
    0x350c, 0x00,
    0x350d, 0x00,
    0x350e, 0x00,
    0x350f, 0x80,
    0x3510, 0x00,
    0x3511, 0x00,
    0x3512, 0x00,
    0x3513, 0x00,
    0x3514, 0x00,
    0x3515, 0x80,
    0x3516, 0x00,
    0x3517, 0x00,
    0x3518, 0x00,
    0x3519, 0x00,
    0x351a, 0x00,
    0x351b, 0x80,
    0x351c, 0x00,
    0x351d, 0x00,
    0x351e, 0x00,
    0x351f, 0x00,
    0x3520, 0x00,
    0x3521, 0x80,
    0x3522, 0x08,
    0x3524, 0x08,
    0x3526, 0x08,
    0x3528, 0x08,
    0x352a, 0x08,
    0x3602, 0x00,
    0x3603, 0x40,
    0x3604, 0x02,
    0x3605, 0x00,
    0x3606, 0x00,
    0x3607, 0x00,
    0x3609, 0x12,
    0x360a, 0x40,
    0x360c, 0x08,
	//0x360f, 0xe5,
    //0x360f, 0xdb,
    0x360f, 0xe0,
    0x3608, 0x8f,
    0x3611, 0x00,
    0x3613, 0xf7,
    0x3616, 0x58,
    0x3619, 0x99,
    0x361b, 0x60,
    0x361c, 0x7a,
    0x361e, 0x79,
    0x361f, 0x02,
    0x3632, 0x00,
    0x3633, 0x10,
    0x3634, 0x10,
    0x3635, 0x10,
	//0x3636, 0x15,
    0x3636, 0x10,
    0x3646, 0x86,
    0x364a, 0x0b,
    0x3700, 0x17,
    0x3701, 0x22,
    0x3703, 0x10,
    0x370a, 0x37,
    0x3705, 0x00,
    0x3706, 0x63,
    0x3709, 0x3c,
    0x370b, 0x01,
    0x370c, 0x30,
    0x3710, 0x24,
    0x3711, 0x0c,
    0x3716, 0x00,
    0x3720, 0x28,
    0x3729, 0x7b,
    0x372a, 0x84,
    0x372b, 0xbd,
    0x372c, 0xbc,
    0x372e, 0x52,
    0x373c, 0x0e,
    0x373e, 0x33,
    0x3743, 0x10,
    0x3744, 0x88,
    0x3745, 0xc0,
    0x374a, 0x43,
    0x374c, 0x00,
    0x374e, 0x23,
    0x3751, 0x7b,
    0x3752, 0x84,
    0x3753, 0xbd,
    0x3754, 0xbc,
    0x3756, 0x52,
    0x375c, 0x00,
    0x3760, 0x00,
    0x3761, 0x00,
    0x3762, 0x00,
    0x3763, 0x00,
    0x3764, 0x00,
    0x3767, 0x04,
    0x3768, 0x04,
    0x3769, 0x08,
    0x376a, 0x08,
    0x376b, 0x20,
    0x376c, 0x00,
    0x376d, 0x00,
    0x376e, 0x00,
    0x3773, 0x00,
    0x3774, 0x51,
    0x3776, 0xbd,
    0x3777, 0xbd,
    0x3781, 0x18,
    0x3783, 0x25,
    0x3798, 0x1b,
    0x3800, 0x00,
    0x3801, 0x06,
    0x3802, 0x00,
    0x3803, 0x02,
    0x3804, 0x0a,
    0x3805, 0x99,
    0x3806, 0x05,
    0x3807, 0xfd,
    0x3808, 0x0a,
    0x3809, 0x84,
    0x380a, 0x05,
    0x380b, 0xf4,
    0x380c, 0x0c,//HTS=3201 for 24 FPS
    0x380d, 0x81,
    0x380e, 0x06,
    0x380f, 0x1a,
    0x3810, 0x00,
    0x3811, 0x08,
    0x3812, 0x00,
    0x3813, 0x04,
    0x3814, 0x01,
    0x3815, 0x01,
    0x3819, 0x01,
#if SENSOR_ROTATE_180
    0x3820, 0x06, // Tom: 0x00: No Flip, 0x06: Row & Column Flip
    0x3821, 0x00, // Tom: 0x06: No Flip, 0x00: Row & Column Flip
#else
    0x3820, 0x00,
    0x3821, 0x06,
#endif
    0x3829, 0x00,
    0x382a, 0x01,
    0x382b, 0x01,
    0x382d, 0x7f,
    0x3830, 0x04,
    0x3836, 0x01,
    0x3837, 0x00,
    0x3841, 0x02,
    0x3846, 0x08,
    0x3847, 0x07,
    0x3d85, 0x36,
    0x3d8c, 0x71,
    0x3d8d, 0xcb,
    0x3f0a, 0x00,
    0x4000, 0xF1,//0x71,
    0x4001, 0x40,
    0x4002, 0x04,
    0x4003, 0x14,
    0x400e, 0x00,
    0x4011, 0x00,
    0x401a, 0x00,
    0x401b, 0x00,
    0x401c, 0x00,
    0x401d, 0x00,
    0x401f, 0x00,
    0x4020, 0x00,
    0x4021, 0x10,
    0x4022, 0x07,
    0x4023, 0xcf,
    0x4024, 0x09,
    0x4025, 0x60,
    0x4026, 0x09,
    0x4027, 0x6f,
    0x4028, 0x00,
    0x4029, 0x02,
    0x402a, 0x06,
    0x402b, 0x04,
    0x402c, 0x02,
    0x402d, 0x02,
    0x402e, 0x0e,
    0x402f, 0x04,
    0x4302, 0xff,
    0x4303, 0xff,
    0x4304, 0x00,
    0x4305, 0x00,
    0x4306, 0x00,
    0x4308, 0x02,
    0x4500, 0x6c,
    0x4501, 0xc4,
    0x4502, 0x40,
    0x4503, 0x01,
    0x4601, 0xA7,
    0x4800, 0x04,
    0x4813, 0x08,
    0x481f, 0x40,
    0x4829, 0x78,
    0x4837, 0x32,///0x2c, // 18
    0x4b00, 0x2a,
    0x4b0d, 0x00,
    0x4d00, 0x04,
    0x4d01, 0x42,
    0x4d02, 0xd1,
    0x4d03, 0x93,
    0x4d04, 0xf5,
    0x4d05, 0xc1,
    0x5000, 0xf3,
    0x5001, 0x11,
    0x5004, 0x00,
    0x500a, 0x00,
    0x500b, 0x00,
    0x5032, 0x00,
    
#if (TEST_PATTERN_EN)
    0x5040, 0x80, // PRE_CONTROL00, 0x00, RW
                  // Bit[7]:   Test pattern enable
                  //           0: disable
                  //           1: enable
                  // Bit[6]:   Rolling bar enable
                  //           0: disable
                  //           1: enable
                  // Bit[5]:   Tansparent enable
                  //           0: disable
                  //           1: enable
                  // Bit[4]:   Square enable
                  //           0: Color square
                  //           1: Black-white square
                  // Bit[3:2]: Color style
                  //           00: Standard color bar
                  //           01: Top-bottom darker color bar
                  //           10: Right-left darker color bar
                  //           11: Bottom-top darker color bar
                  // Bit[1:0]: Test pattern mode
                  //           00: Color bar
                  //           01: Random data
                  //           10: Square
                  //           01: Black image
    0x5041, 0x00, // PRE_CONTROL01, 0x41, RW
                  // Bit[6]:   Window cut enable
                  //           0: disable
                  //           1: enable
                  // Bit[4]:   Same seed enable
                  //           When set, the seed used to generate the
                  //           random data are same which is set in
                  //           seed register
                  // Bit[3:0]: Seed
                  //           Seed used in generating random data
#else
    0x5040, 0x00,
#endif
    0x5050, 0x0c,
    0x5500, 0x00,
    0x5501, 0x10,
    0x5502, 0x01,
    0x5503, 0x0f,
    0x8000, 0x00,
    0x8001, 0x00,
    0x8002, 0x00,
    0x8003, 0x00,
    0x8004, 0x00,
    0x8005, 0x00,
    0x8006, 0x00,
    0x8007, 0x00,
    0x8008, 0x00,
    0x3638, 0x00,
    0x0100, 0x01,
#endif
};

// OPR Table Setting
static MMPF_SENSOR_OPR_TABLE m_OprTable = 
{
    // usInitSize
    (sizeof(SNR_OV4689_Reg_Init_Customer)/sizeof(SNR_OV4689_Reg_Init_Customer[0]))/2,

    // uspInitTable
    &SNR_OV4689_Reg_Init_Customer[0],

    MMP_FALSE,  // bBinTableExist
    0,          // usBinTableNum
    {0},        // usBinRegAddr
    {0},        // usBinSize
    {NULL},     // ubBinTable

    MMP_FALSE,  // bInitDoneTableExist
    0,          // usInitDoneSize
    NULL,       // uspInitDoneTable

    // usSize
    {
    #if (HDR_FOV_ENLARGE)
        (sizeof(SNR_OV4689_Reg_2432x1368_60P_HDR)/sizeof(SNR_OV4689_Reg_2432x1368_60P_HDR[0]))/2,
    #else
        (sizeof(SNR_OV4689_Reg_2312x1520_60P_HDR)/sizeof(SNR_OV4689_Reg_2312x1520_60P_HDR[0]))/2,
    #endif
        (sizeof(SNR_OV4689_Reg_2688x1520_60P)/sizeof(SNR_OV4689_Reg_2688x1520_60P[0]))/2,
        (sizeof(SNR_OV4689_Reg_2688x1520_30P)/sizeof(SNR_OV4689_Reg_2688x1520_30P[0]))/2,
        (sizeof(SNR_OV4689_Reg_1280x960_30P)/sizeof(SNR_OV4689_Reg_1280x960_30P[0]))/2,
        (sizeof(SNR_OV4689_Reg_1920x1080_30P)/sizeof(SNR_OV4689_Reg_1920x1080_30P[0]))/2,
        (sizeof(SNR_OV4689_Reg_1920x1080_50P)/sizeof(SNR_OV4689_Reg_1920x1080_50P[0]))/2,
        (sizeof(SNR_OV4689_Reg_1920x1080_60P)/sizeof(SNR_OV4689_Reg_1920x1080_60P[0]))/2,
        (sizeof(SNR_OV4689_Reg_2032x1524_30P)/sizeof(SNR_OV4689_Reg_2032x1524_30P[0]))/2,
        (sizeof(SNR_OV4689_Reg_1920x1080_15P)/sizeof(SNR_OV4689_Reg_1920x1080_15P[0]))/2,
        (sizeof(SNR_OV4689_Reg_1280x720_30P)/sizeof(SNR_OV4689_Reg_1280x720_30P[0]))/2,
        (sizeof(SNR_OV4689_Reg_1280x720_60P)/sizeof(SNR_OV4689_Reg_1280x720_60P[0]))/2,
        (sizeof(SNR_OV4689_Reg_1280x720_100P)/sizeof(SNR_OV4689_Reg_1280x720_100P[0]))/2,
        (sizeof(SNR_OV4689_Reg_1280x720_120P)/sizeof(SNR_OV4689_Reg_1280x720_120P[0]))/2,
        (sizeof(SNR_OV4689_Reg_640x480_30P)/sizeof(SNR_OV4689_Reg_640x480_30P[0]))/2,
        (sizeof(SNR_OV4689_Reg_1520x1520_30P)/sizeof(SNR_OV4689_Reg_1520x1520_30P[0]))/2,
        (sizeof(SNR_OV4689_Reg_2688x1512_24P)/sizeof(SNR_OV4689_Reg_2688x1512_24P[0]))/2,
    },

    // uspTable
    {
    #if (HDR_FOV_ENLARGE)
        &SNR_OV4689_Reg_2432x1368_60P_HDR[0],
    #else
        &SNR_OV4689_Reg_2312x1520_60P_HDR[0],
    #endif
        &SNR_OV4689_Reg_2688x1520_60P[0],
        &SNR_OV4689_Reg_2688x1520_30P[0],
        &SNR_OV4689_Reg_1280x960_30P[0],
        &SNR_OV4689_Reg_1920x1080_30P[0],
        &SNR_OV4689_Reg_1920x1080_50P[0],
        &SNR_OV4689_Reg_1920x1080_60P[0],
        &SNR_OV4689_Reg_2032x1524_30P[0],
        &SNR_OV4689_Reg_1920x1080_15P[0],
        &SNR_OV4689_Reg_1280x720_30P[0],
        &SNR_OV4689_Reg_1280x720_60P[0],
        &SNR_OV4689_Reg_1280x720_100P[0],
        &SNR_OV4689_Reg_1280x720_120P[0],
        &SNR_OV4689_Reg_640x480_30P[0],
        &SNR_OV4689_Reg_1520x1520_30P[0],
        &SNR_OV4689_Reg_2688x1512_24P[0]
    }
};

#if 0
void ____Sensor_Customer_Func____(){ruturn;} // dummy
#endif

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_InitConfig
//  Description :
//------------------------------------------------------------------------------
static void SNR_Cust_InitConfig(void)
{
    RTNA_DBG_Str(0, "SNR_Cust_InitConfig OV4689\r\n");
    
    if ((gsHdrCfg.bVidEnable || gsHdrCfg.bDscEnable) && 
        (gsHdrCfg.ubMode == HDR_MODE_STAGGER))
    {
        m_VifSetting_Prm.vcAttr.bEnable             = MMP_TRUE;
        m_VifSetting_Prm.vcAttr.bAllChannel2Isp     = MMP_TRUE;
        m_VifSetting_Prm.vcAttr.bVC2Isp[0]          = MMP_TRUE;
        m_VifSetting_Prm.vcAttr.bVC2Isp[1]          = MMP_TRUE;
        m_VifSetting_Prm.vcAttr.bVC2Isp[2]          = MMP_FALSE;
        m_VifSetting_Prm.vcAttr.bVC2Isp[3]          = MMP_FALSE;
        m_VifSetting_Prm.vcAttr.bVC2Raw[0]          = MMP_FALSE;
        m_VifSetting_Prm.vcAttr.bVC2Raw[1]          = MMP_FALSE;
        m_VifSetting_Prm.vcAttr.bVC2Raw[2]          = MMP_FALSE;
        m_VifSetting_Prm.vcAttr.bVC2Raw[3]          = MMP_FALSE;
        m_VifSetting_Prm.vcAttr.bSlowFsForStagger   = MMP_TRUE;
    }
    else {
        m_VifSetting_Prm.vcAttr.bEnable             = MMP_FALSE;
        m_VifSetting_Prm.vcAttr.bAllChannel2Isp     = MMP_FALSE;
        m_VifSetting_Prm.vcAttr.bVC2Isp[0]          = MMP_FALSE;
        m_VifSetting_Prm.vcAttr.bVC2Isp[1]          = MMP_FALSE;
        m_VifSetting_Prm.vcAttr.bVC2Isp[2]          = MMP_FALSE;
        m_VifSetting_Prm.vcAttr.bVC2Isp[3]          = MMP_FALSE;
        m_VifSetting_Prm.vcAttr.bVC2Raw[0]          = MMP_FALSE;
        m_VifSetting_Prm.vcAttr.bVC2Raw[1]          = MMP_FALSE;
        m_VifSetting_Prm.vcAttr.bVC2Raw[2]          = MMP_FALSE;
        m_VifSetting_Prm.vcAttr.bVC2Raw[3]          = MMP_FALSE;
        m_VifSetting_Prm.vcAttr.bSlowFsForStagger   = MMP_FALSE;
    }  
}

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_DoAE_FrmSt
//  Description :
//------------------------------------------------------------------------------
static void SNR_Cust_DoAE_FrmSt(MMP_UBYTE ubSnrSel, MMP_ULONG ulFrameCnt)
{
#if (ISP_EN)
    MMP_ULONG   ulVsync = 0;
    MMP_ULONG   ulShutter = 0;
    MMP_ULONG   ulSetShutCurISPFrameCnt;
    MMP_ULONG   ulSetGainDoneCurISPFrameCnt;
    
    if ((gsHdrCfg.bVidEnable || gsHdrCfg.bDscEnable) && 
        (gsHdrCfg.ubMode == HDR_MODE_STAGGER))
    {
        #define SENSOR_GROUP_LAUNCH     (1)
        
        if ((ulFrameCnt % m_AeTime.ubPeriod) == 0)
        {
            ISP_IF_AE_Execute();

            // Get long exposure
            ae_shutter_l = ISP_IF_AE_GetShutter();
            ae_gain_l    = ISP_IF_AE_GetGain();        

            ae_shutter_s = ISP_IF_IQ_GetHDR_ShortShutter();
            ae_gain_s    = ISP_IF_IQ_GetHDR_ShortGain();

            if (ae_gain_l >= ISP_IF_AE_GetGainBase() * MAX_SENSOR_GAIN) {
               dgain      = ISP_DGAIN_BASE * ae_gain_l / ISP_IF_AE_GetGainBase() / MAX_SENSOR_GAIN;
               ae_gain_l  = ISP_IF_AE_GetGainBase() * MAX_SENSOR_GAIN;
            }
            else {
                dgain = ISP_DGAIN_BASE;
            }

            ae_gain_s = ae_gain_s * ISP_DGAIN_BASE / dgain;
            
            // Sensor limit
            if (ae_shutter_l <= ae_shutter_s)   
                ae_shutter_l = ae_shutter_s + 1;
        }
        
        // For AE curve
        if (ulFrameCnt % 100 == 10) {
            #ifdef HB_IQ_VER    // temp, For DVR002
            if ((HB_IQ_VER == 4) || (HB_IQ_VER == 5))
                ISP_IF_CMD_SendCommandtoAE(0x52, AE_Bias_tbl, AE_tbl_size, 1);
            else
                ISP_IF_CMD_SendCommandtoAE(0x51, AE_Bias_tbl, AE_tbl_size, 0);
            #else
            ISP_IF_CMD_SendCommandtoAE(0x51, AE_Bias_tbl, AE_tbl_size, 0); // <<AE table set once at preview start
            #endif
            ISP_IF_NaturalAE_Enable(2);	//0: no , 1:ENERGY 2: Lux 3: test mode
        }
		#if (SENSOR_GROUP_LAUNCH)
		gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x3208, 0x0);  //group 0 start
        #endif
        
        // Set shutter
        if ((ulFrameCnt % m_AeTime.ubPeriod) == m_AeTime.ubFrmStSetShutFrmCnt) {
            gsSensorFunction->MMPF_Sensor_SetShutter(ubSnrSel, 0, 0);    
        }
        
        // Set gain
        if ((ulFrameCnt % m_AeTime.ubPeriod) == m_AeTime.ubFrmStSetGainFrmCnt) {
            gsSensorFunction->MMPF_Sensor_SetGain(ubSnrSel, 0);
       	}

       	ISP_IF_IQ_SetAEGain(dgain, ISP_DGAIN_BASE);

        #if (SENSOR_GROUP_LAUNCH)
        gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x3208, 0x10); //group 0 end
        gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x320B, 0x00); //group 0 manual launch on
        gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x3208, 0xA0); //group 0 delay launch
        #endif
    }
    else
    {
        extern MMP_ULONG  m_ulISPFrameCount;
        static ISP_UINT16 ae_gain;
        static ISP_UINT16 ae_shutter;
        static ISP_UINT16 ae_vsync;
        
        ISP_IF_CMD_SendCommandtoAE(0x52, AE_Bias_tbl, AE_tbl_size, 1);
        
        if ((ulFrameCnt % m_AeTime.ubPeriod) == 0)
        {
            ISP_IF_AE_Execute();
            
            ae_gain     = ISP_IF_AE_GetGain();
            ae_shutter  = ISP_IF_AE_GetShutter();
            ae_vsync    = ISP_IF_AE_GetVsync();
        }

        ulVsync 	= (gSnrLineCntPerSec[ubSnrSel] * ISP_IF_AE_GetVsync()) / ISP_IF_AE_GetVsyncBase();
        ulShutter 	= (gSnrLineCntPerSec[ubSnrSel] * ISP_IF_AE_GetShutter()) / ISP_IF_AE_GetShutterBase();

        if ((ulFrameCnt % m_AeTime.ubPeriod) == m_AeTime.ubFrmStSetGainFrmCnt)
       	{
            if (ae_gain >= ISP_IF_AE_GetGainBase() * MAX_SENSOR_GAIN) {

                dgain  	= ISP_DGAIN_BASE * ae_gain /ISP_IF_AE_GetGainBase() / MAX_SENSOR_GAIN ;
                ae_gain	= ISP_IF_AE_GetGainBase() * MAX_SENSOR_GAIN;
            }
            else {
                dgain 	= ISP_DGAIN_BASE;
            }
        }
        
        if (CAM_CHECK_SCD(SCD_CAM_BAYER_SENSOR)) {
            if ((ulFrameCnt % m_AeTime.ubPeriod) == m_AeTime.ubFrmStSetShutFrmCnt) {

                gsSensorFunction->MMPF_Sensor_SetExposure(PRM_SENSOR, ae_gain, ulShutter, ulVsync);
                gsSensorFunction->MMPF_Sensor_SetExposure(SCD_SENSOR, ae_gain, ulShutter, ulVsync);
            }
        }
        else {
        
            if ((ulFrameCnt % m_AeTime.ubPeriod) == m_AeTime.ubFrmStSetShutFrmCnt) {
                
                ulSetShutCurISPFrameCnt = m_ulISPFrameCount;
                gsSensorFunction->MMPF_Sensor_SetShutter(ubSnrSel, ulShutter, ulVsync);
            }
            
            if ((ulFrameCnt % m_AeTime.ubPeriod) == m_AeTime.ubFrmStSetGainFrmCnt) {
                
                gsSensorFunction->MMPF_Sensor_SetGain(ubSnrSel, ae_gain);
                ulSetGainDoneCurISPFrameCnt = m_ulISPFrameCount;
                
                if (ulSetShutCurISPFrameCnt != ulSetGainDoneCurISPFrameCnt) {
                    RTNA_DBG_Str0("Set AE and Shutter over ");
                    RTNA_DBG_Byte0(ulSetGainDoneCurISPFrameCnt - ulSetShutCurISPFrameCnt);
                    RTNA_DBG_Str0(" frame duration\r\n");
                }
            }
        }

        if ((ulFrameCnt % m_AeTime.ubPeriod) == m_AeTime.ubFrmStSetGainFrmCnt + 1) {
            ISP_IF_IQ_SetAEGain(dgain, ISP_DGAIN_BASE);
        }
    }
#endif
}

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_DoAE_FrmEnd
//  Description :
//------------------------------------------------------------------------------
static void SNR_Cust_DoAE_FrmEnd(MMP_UBYTE ubSnrSel, MMP_ULONG ulFrameCnt)
{
    // TBD
}

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_DoAWB_FrmSt
//  Description :
//------------------------------------------------------------------------------
static void SNR_Cust_DoAWB_FrmSt(MMP_UBYTE ubSnrSel, MMP_ULONG ulFrameCnt)
{
    // TBD
}

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_DoAWB_FrmEnd
//  Description :
//------------------------------------------------------------------------------
static void SNR_Cust_DoAWB_FrmEnd(MMP_UBYTE ubSnrSel, MMP_ULONG ulFrameCnt)
{
    // TBD
}

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_DoIQ
//  Description :
//------------------------------------------------------------------------------
static void SNR_Cust_DoIQ(MMP_UBYTE ubSnrSel, MMP_ULONG ulFrameCnt)
{
	// TBD
}

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_SetGain
//  Description :
//------------------------------------------------------------------------------
static void SNR_Cust_SetGain(MMP_UBYTE ubSnrSel, MMP_ULONG ulGain)
{
#if (ISP_EN)

     static MMP_UBYTE temp_sensor_H = 0;
     static MMP_UBYTE temp_sensor_L = 0;
     
    if ((gsHdrCfg.bVidEnable || gsHdrCfg.bDscEnable) && 
        (gsHdrCfg.ubMode == HDR_MODE_STAGGER))
    {
        ISP_UINT16  sensor_H;
        ISP_UINT16  sensor_L;
        MMP_ULONG   ulTempGain;

        ulTempGain = ae_gain_l;
        
        /* Sensor Gain Mapping */
        if ((ulTempGain >> 8) < 2)
        {
            sensor_H = 0;
            sensor_L = (ulTempGain * 128) >> 8;                 // 1X ~ 2X
        }
        else if ((ulTempGain >> 8) < 4)
        {
            sensor_H = 1;   
            sensor_L = ((ulTempGain * 64) - (256 * 8)) >> 8;    // 2X ~ 4X
        }       
        else if ((ulTempGain >> 8) < 8)
        {
            sensor_H = 3;   
            sensor_L = ((ulTempGain * 32) - (256 * 12)) >> 8;   // 4X ~ 8X
        }   
        else
        {
            sensor_H = 7;
            sensor_L = ((ulTempGain * 16) - (256 * 8)) >> 8;    // 8X ~16X
        }

        // Long Gain
        gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x3508, sensor_H);
        gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x3509, sensor_L);

        ulTempGain = ae_gain_s;

        /* Sensor Gain Mapping */
        if ((ulTempGain >> 8) < 2)
        {
            sensor_H = 0;
            sensor_L = (ulTempGain * 128) >> 8;                 // 1X ~ 2X
        }
        else if ((ulTempGain >> 8) < 4)
        {
            sensor_H = 1;   
            sensor_L = ((ulTempGain * 64) - (256 * 8)) >> 8;    // 2X ~ 4X
        }       
        else if ((ulTempGain >> 8) < 8)
        {
            sensor_H = 3;   
            sensor_L = ((ulTempGain * 32) - (256 * 12)) >> 8;   // 4X ~ 8X
        }   
        else
        {
            sensor_H = 7;
            sensor_L = ((ulTempGain * 16) - (256 * 8)) >> 8;    // 8X ~16X
        }
        
        // Middle Gain
        gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x350E, sensor_H);
        gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x350F, sensor_L);
    }
    else
    {
        ISP_UINT16 sensor_H;
        ISP_UINT16 sensor_L;
        ISP_UINT16 array[4];
        
        /* Sensor Gain Mapping */
        if ((ulGain>>8) < 2)
        {
            sensor_H = 0;
            sensor_L = (ulGain * 128) >> 8;                 // 1X ~ 2X
        }
        else if ((ulGain >> 8) < 4)
        {
            sensor_H = 1;   
            sensor_L = ((ulGain * 64) - (256 * 8)) >> 8;    // 2X ~ 4X
        }       
        else if ((ulGain >> 8) < 8)
        {
            sensor_H = 3;   
            sensor_L = ((ulGain * 32) - (256 * 12)) >> 8;   // 4X ~ 8X
        }   
        else
        {
            sensor_H = 7;
            sensor_L = ((ulGain * 16) - (256 * 8)) >> 8;    // 8X ~16X
        }

        array[0] = 0x3508;
        array[1] = sensor_H;
        array[2] = 0x3509;
        array[3] = sensor_L;

        if(temp_sensor_H == sensor_H && temp_sensor_L == sensor_L) return;
        
        if (CAM_CHECK_SCD(SCD_CAM_BAYER_SENSOR)) {
            gsSensorFunction->MMPF_Sensor_SetRegArray(ubSnrSel, array, ARRAY_SIZE(array)/2);
        }
        else {
            gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x3508, sensor_H);
            gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x3509, sensor_L);
        }

        temp_sensor_H = sensor_H;
        temp_sensor_L = sensor_L;
    }
#endif
}

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_SetShutter
//  Description :
//------------------------------------------------------------------------------
void SNR_Cust_SetShutter(MMP_UBYTE ubSnrSel, MMP_ULONG shutter, MMP_ULONG vsync)
{
#if (ISP_EN)

       static ISP_UINT32 temp_vysnc = 0;
       static ISP_UINT32 temp_shutter = 0;
       
       static ISP_UINT32 hdr_temp_shutter_Long = 0;
       static ISP_UINT32 hdr_temp_shutter_Short = 0;
     
    if ((gsHdrCfg.bVidEnable || gsHdrCfg.bDscEnable) && 
        (gsHdrCfg.ubMode == HDR_MODE_STAGGER))
    {
        // Long Expo
        gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x3500, (ISP_UINT8)((ae_shutter_l >> 12) & 0xFF));
        gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x3501, (ISP_UINT8)((ae_shutter_l >> 4) & 0xFF));
        gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x3502, (ISP_UINT8)((ae_shutter_l << 4) & 0xFF));
        
        // Middle Expo
        gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x350A, (ISP_UINT8)((ae_shutter_s >> 12) & 0xFF));
        gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x350B, (ISP_UINT8)((ae_shutter_s >> 4) & 0xFF));
        gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x350C, (ISP_UINT8)((ae_shutter_s << 4) & 0xFF));
        
        hdr_temp_shutter_Long = ae_shutter_l;
        hdr_temp_shutter_Short = ae_shutter_s;
    }
    else
    {
        ISP_UINT32 new_vsync;
        ISP_UINT32 new_shutter;
        ISP_UINT16 array[10];
        
        if ((shutter == 0 ) || (vsync == 0))
        {
            new_vsync    = gSnrLineCntPerSec[ubSnrSel] * ISP_IF_AE_GetVsync() / ISP_IF_AE_GetVsyncBase();
            new_shutter  = gSnrLineCntPerSec[ubSnrSel] * ISP_IF_AE_GetShutter() / ISP_IF_AE_GetShutterBase();
        }
        else
        {
            new_vsync   = vsync;
            new_shutter = shutter;
        }
        new_vsync   = ISP_MIN(ISP_MAX((new_shutter), new_vsync), 0xFFFF);
        new_shutter = ISP_MIN(ISP_MAX(new_shutter, 1), (new_vsync - 4));
        
        if(temp_vysnc == new_vsync && temp_shutter == new_shutter) return;

        array[0] = 0x380E;
        array[1] = (new_vsync >> 8);
        array[2] = 0x380F;
        array[3] = new_vsync;
        
        array[4] = 0x3500;
        array[5] = (ISP_UINT8)((new_shutter >> 12) & 0xFF);
        array[6] = 0x3501;
        array[7] = (ISP_UINT8)((new_shutter >> 4) & 0xFF);
        array[8] = 0x3502;
        array[9] = (ISP_UINT8)((new_shutter << 4) & 0xFF);
        
        if (CAM_CHECK_SCD(SCD_CAM_BAYER_SENSOR)) {
            gsSensorFunction->MMPF_Sensor_SetRegArray(ubSnrSel, array, ARRAY_SIZE(array)/2);    
        }
        else {
            gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x380E, (new_vsync >> 8));
            gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x380F, new_vsync);

            gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x3500, (ISP_UINT8)((new_shutter >> 12) & 0xFF));
            gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x3501, (ISP_UINT8)((new_shutter >> 4) & 0xFF));
            gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x3502, (ISP_UINT8)((new_shutter << 4) & 0xFF));
        }

        temp_vysnc = new_vsync;
        temp_shutter = new_shutter;
    }
#endif
}

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_SetExposure
//  Description :
//------------------------------------------------------------------------------
static void SNR_Cust_SetExposure(MMP_UBYTE ubSnrSel, MMP_ULONG ulGain, MMP_ULONG shutter, MMP_ULONG vsync)
{
#if (ISP_EN)
    if ((gsHdrCfg.bVidEnable || gsHdrCfg.bDscEnable) && 
        (gsHdrCfg.ubMode == HDR_MODE_STAGGER))
    {
        // TBD
    }
    else
    {
        ISP_UINT32 new_vsync;
        ISP_UINT32 new_shutter;
        ISP_UINT16 sensor_H;
        ISP_UINT16 sensor_L;
        ISP_UINT16 array[14];

        // Gain Setting
        if ((ulGain>>8) < 2)
        {
            sensor_H = 0;
            sensor_L = (ulGain * 128) >> 8;                 // 1X ~ 2X
        }
        else if ((ulGain >> 8) < 4)
        {
            sensor_H = 1;
            sensor_L = ((ulGain * 64) - (256 * 8)) >> 8;    // 2X ~ 4X
        }
        else if ((ulGain >> 8) < 8)
        {
            sensor_H = 3;
            sensor_L = ((ulGain * 32) - (256 * 12)) >> 8;   // 4X ~ 8X
        }
        else
        {
            sensor_H = 7;
            sensor_L = ((ulGain * 16) - (256 * 8)) >> 8;    // 8X ~16X
        }

        array[0] = 0x3508;
        array[1] = sensor_H;
        array[2] = 0x3509;
        array[3] = sensor_L;
       
        // Shutter Setting
        new_vsync   = ISP_MIN(ISP_MAX((shutter), vsync), 0xFFFF);
        new_shutter = ISP_MIN(ISP_MAX(shutter, 1), (vsync - 4));
        
        array[4] = 0x380E;
        array[5] = (new_vsync >> 8);
        array[6] = 0x380F;
        array[7] = new_vsync;
        
        array[8] = 0x3500;
        array[9] = (ISP_UINT8)((new_shutter >> 12) & 0xFF);
        array[10] = 0x3501;
        array[11] = (ISP_UINT8)((new_shutter >> 4) & 0xFF);
        array[12] = 0x3502;
        array[13] = (ISP_UINT8)((new_shutter << 4) & 0xFF);
        
        // Set data via I2C
        gsSensorFunction->MMPF_Sensor_SetRegArray(ubSnrSel, array, ARRAY_SIZE(array)/2);
    }
#endif
}

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_SetFlip
//  Description :
//------------------------------------------------------------------------------
void SNR_Cust_SetFlip(MMP_UBYTE ubSnrSel, MMP_UBYTE ubMode)
{
    MMP_USHORT  usRdVal1, usRdVal2;

    #define SENSOR_FLIP_MASK_BITS (0x06)
    
    gsSensorFunction->MMPF_Sensor_GetReg(ubSnrSel, 0x3820, &usRdVal1);//v
    gsSensorFunction->MMPF_Sensor_GetReg(ubSnrSel, 0x3821, &usRdVal2);//h
    
    if (ubMode == MMPF_SENSOR_NO_FLIP) 
    {
        usRdVal1 &= ~SENSOR_FLIP_MASK_BITS;
        usRdVal2 |= SENSOR_FLIP_MASK_BITS;
        m_VifSetting_Prm.colorId.VifColorId = MMPF_VIF_COLORID_11;
    }
    else if (ubMode == MMPF_SENSOR_COLUMN_FLIP)
    {
        usRdVal1 |= SENSOR_FLIP_MASK_BITS;
        usRdVal2 |= SENSOR_FLIP_MASK_BITS;
        m_VifSetting_Prm.colorId.VifColorId = MMPF_VIF_COLORID_10;
    }
    else if (ubMode == MMPF_SENSOR_ROW_FLIP)
    {
        usRdVal1 &= ~SENSOR_FLIP_MASK_BITS;
        usRdVal2 &= ~SENSOR_FLIP_MASK_BITS;
        m_VifSetting_Prm.colorId.VifColorId = MMPF_VIF_COLORID_01;
    }
    else if (ubMode == MMPF_SENSOR_COLROW_FLIP)
    {
        usRdVal1 |= SENSOR_FLIP_MASK_BITS;
        usRdVal2 &= ~SENSOR_FLIP_MASK_BITS;
        m_VifSetting_Prm.colorId.VifColorId = MMPF_VIF_COLORID_00;
    }
    else {
        return;
    }

    gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x3820, usRdVal1);
    gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x3821, usRdVal2);
}

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_SetRotate
//  Description :
//------------------------------------------------------------------------------
void SNR_Cust_SetRotate(MMP_UBYTE ubSnrSel, MMP_UBYTE ubMode)
{
    // TBD
}

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_CheckVersion
//  Description :
//------------------------------------------------------------------------------
void SNR_Cust_CheckVersion(MMP_UBYTE ubSnrSel, MMP_ULONG *pulVersion)
{
    // TBD
}

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_GetIqCompressData
//  Description :
//------------------------------------------------------------------------------
const MMP_UBYTE* SNR_Cust_GetIqCompressData(MMP_UBYTE ubSnrSel)
{
    return s_IqCompressData;
}

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_StreamEnable
//  Description : Enable/Disable streaming of sensor
//------------------------------------------------------------------------------
static void SNR_Cust_StreamEnable(MMP_UBYTE ubSnrSel, MMP_BOOL bEnable)
{
    if (bEnable) {
        gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x0100, 0x01);
    }
    else {
        gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x0100, 0x00);
    }
}

MMPF_SENSOR_CUSTOMER SensorCustFunc_Prm = 
{
    SNR_Cust_InitConfig,
    SNR_Cust_DoAE_FrmSt,
    SNR_Cust_DoAE_FrmEnd,
    SNR_Cust_DoAWB_FrmSt,
    SNR_Cust_DoAWB_FrmEnd,
    SNR_Cust_DoIQ,
    SNR_Cust_SetGain,
    SNR_Cust_SetShutter,
    SNR_Cust_SetExposure,
    SNR_Cust_SetFlip,
    SNR_Cust_SetRotate,
    SNR_Cust_CheckVersion,
    SNR_Cust_GetIqCompressData,
    SNR_Cust_StreamEnable,
    
    &m_SensorRes,
    &m_OprTable,
    &m_VifSetting_Prm,
    &m_I2cmAttr_Prm,
    &m_AwbTime,
    &m_AeTime,
    &m_AfTime,
    MMP_SNR_PRIO_PRM
};

#if defined(BIND_SENSOR_OV4689_2ND) && (BIND_SENSOR_OV4689_2ND)
static MMPF_SENSOR_CUSTOMER SensorCustFunc_Scd =
{
    SNR_Cust_InitConfig,
    SNR_Cust_DoAE_FrmSt,
    SNR_Cust_DoAE_FrmEnd,
    SNR_Cust_DoAWB_FrmSt,
    SNR_Cust_DoAWB_FrmEnd,
    SNR_Cust_DoIQ,
    SNR_Cust_SetGain,
    SNR_Cust_SetShutter,
    SNR_Cust_SetExposure,
    SNR_Cust_SetFlip,
    SNR_Cust_SetRotate,
    SNR_Cust_CheckVersion,
    SNR_Cust_GetIqCompressData,
    SNR_Cust_StreamEnable,

    &m_SensorRes,
    &m_OprTable,
    &m_VifSetting_Scd,
    &m_I2cmAttr_Scd,
    &m_AwbTime,
    &m_AeTime,
    &m_AfTime,
    MMP_SNR_PRIO_SCD
};
#endif

int SNR_Module_Init(void)
{
    if (SensorCustFunc_Prm.sPriority == MMP_SNR_PRIO_PRM)
        MMPF_SensorDrv_Register(PRM_SENSOR, &SensorCustFunc_Prm);
    else
        MMPF_SensorDrv_Register(SCD_SENSOR, &SensorCustFunc_Prm);
        
#if defined(BIND_SENSOR_OV4689_2ND) && (BIND_SENSOR_OV4689_2ND)
    MMPF_SensorDrv_Register(SCD_SENSOR, &SensorCustFunc_Scd);
#endif
    
    return 0;
}

#pragma arm section code = "initcall6", rodata = "initcall6", rwdata = "initcall6",  zidata = "initcall6" 
#pragma O0
ait_module_init(SNR_Module_Init);
#pragma
#pragma arm section rodata, rwdata, zidata

#endif // (BIND_SENSOR_OV4689)
#endif // (SENSOR_EN)
